
//----------------------------------------------------
// The following code was generated by CUP v0.11a beta 20060608
// Thu Apr 26 13:05:51 CEST 2018
//----------------------------------------------------

package compiler.syntax;

import java_cup.runtime.Symbol;
import java.util.*;
import es.uned.lsi.compiler.lexical.*;
import es.uned.lsi.compiler.code.*;
import es.uned.lsi.compiler.intermediate.*;
import es.uned.lsi.compiler.semantic.*;
import es.uned.lsi.compiler.semantic.symbol.*;
import es.uned.lsi.compiler.semantic.type.*;
import es.uned.lsi.compiler.syntax.*;
import compiler.CompilerContext;
import compiler.lexical.*;
import compiler.syntax.nonTerminal.*;
import compiler.semantic.*;
import compiler.semantic.symbol.*;
import compiler.semantic.type.*;
import compiler.intermediate.*;
import compiler.code.*;

/** CUP v0.11a beta 20060608 generated parser.
  * @version Thu Apr 26 13:05:51 CEST 2018
  */
public class parser extends java_cup.runtime.lr_parser {

  /** Default constructor. */
  public parser() {super();}

  /** Constructor which sets the default scanner. */
  public parser(java_cup.runtime.Scanner s) {super(s);}

  /** Constructor which sets the default scanner. */
  public parser(java_cup.runtime.Scanner s, java_cup.runtime.SymbolFactory sf) {super(s,sf);}

  /** Production table. */
  protected static final short _production_table[][] = 
    unpackFromStrings(new String[] {
    "\000\143\000\002\002\004\000\002\052\002\000\002\002" +
    "\004\000\002\053\002\000\002\045\004\000\002\054\002" +
    "\000\002\003\005\000\002\003\003\000\002\004\004\000" +
    "\002\004\003\000\002\005\004\000\002\005\003\000\002" +
    "\006\004\000\002\006\003\000\002\055\002\000\002\010" +
    "\007\000\002\056\002\000\002\012\010\000\002\057\002" +
    "\000\002\015\006\000\002\060\002\000\002\015\006\000" +
    "\002\016\005\000\002\014\004\000\002\014\004\000\002" +
    "\017\004\000\002\017\006\000\002\017\006\000\002\017" +
    "\005\000\002\017\007\000\002\017\007\000\002\020\004" +
    "\000\002\020\005\000\002\061\002\000\002\021\007\000" +
    "\002\021\006\000\002\007\007\000\002\023\004\000\002" +
    "\062\002\000\002\023\006\000\002\024\005\000\002\024" +
    "\007\000\002\022\003\000\002\022\003\000\002\063\002" +
    "\000\002\035\005\000\002\064\002\000\002\035\006\000" +
    "\002\036\003\000\002\011\004\000\002\011\003\000\002" +
    "\011\003\000\002\013\004\000\002\013\003\000\002\013" +
    "\003\000\002\037\003\000\002\037\004\000\002\037\003" +
    "\000\002\037\004\000\002\040\003\000\002\040\003\000" +
    "\002\040\003\000\002\040\003\000\002\040\004\000\002" +
    "\040\004\000\002\040\003\000\002\026\005\000\002\026" +
    "\007\000\002\027\003\000\002\027\003\000\002\027\005" +
    "\000\002\027\003\000\002\027\005\000\002\027\005\000" +
    "\002\027\005\000\002\027\005\000\002\027\005\000\002" +
    "\025\003\000\002\025\003\000\002\030\004\000\002\031" +
    "\004\000\002\031\005\000\002\032\003\000\002\032\005" +
    "\000\002\033\003\000\002\033\005\000\002\041\007\000" +
    "\002\041\007\000\002\041\011\000\002\041\011\000\002" +
    "\041\011\000\002\041\011\000\002\042\007\000\002\042" +
    "\007\000\002\043\007\000\002\043\006\000\002\044\007" +
    "\000\002\034\005\000\002\034\004" });

  /** Access to production table. */
  public short[][] production_table() {return _production_table;}

  /** Parse-action table. */
  protected static final short[][] _action_table = 
    unpackFromStrings(new String[] {
    "\000\276\000\012\004\000\005\000\010\000\015\000\001" +
    "\002\000\004\002\300\001\002\000\012\004\ufffe\005\ufffe" +
    "\010\ufffe\015\ufffe\001\002\000\012\004\025\005\010\010" +
    "\012\015\014\001\002\000\004\002\uffff\001\002\000\004" +
    "\004\274\001\002\000\012\004\ufffc\005\ufffc\010\ufffc\015" +
    "\ufffc\001\002\000\004\004\271\001\002\000\004\002\ufff8" +
    "\001\002\000\006\004\262\011\263\001\002\000\006\027" +
    "\257\030\260\001\002\000\006\027\251\030\252\001\002" +
    "\000\004\002\ufff4\001\002\000\004\002\ufffa\001\002\000" +
    "\006\010\246\015\014\001\002\000\004\002\ufff6\001\002" +
    "\000\004\002\ufffd\001\002\000\010\004\025\010\031\015" +
    "\014\001\002\000\004\004\030\001\002\000\010\004\025" +
    "\010\012\015\014\001\002\000\004\002\ufff9\001\002\000" +
    "\006\027\uffe2\030\uffe2\001\002\000\004\004\033\001\002" +
    "\000\004\002\ufff7\001\002\000\012\021\uffe0\027\uffe8\030" +
    "\uffe8\035\034\001\002\000\006\004\245\020\244\001\002" +
    "\000\004\021\036\001\002\000\010\004\230\010\233\022" +
    "\227\001\002\000\004\025\041\001\002\000\006\010\uffdf" +
    "\015\uffdf\001\002\000\024\004\uffd3\006\uffd3\010\uffd3\012" +
    "\uffd3\013\uffd3\014\uffd3\016\uffd3\025\uffd3\026\uffd5\001\002" +
    "\000\022\004\067\006\061\010\071\012\064\013\060\014" +
    "\056\016\053\025\041\001\002\000\004\026\044\001\002" +
    "\000\032\002\uffd4\004\uffd4\006\uffd4\007\uffd4\010\uffd4\012" +
    "\uffd4\013\uffd4\014\uffd4\015\uffd4\016\uffd4\025\uffd4\026\uffd4" +
    "\001\002\000\024\004\uffc4\006\uffc4\007\uffc4\012\uffc4\013" +
    "\uffc4\014\uffc4\016\uffc4\025\uffc4\026\uffc4\001\002\000\004" +
    "\026\uffce\001\002\000\024\004\uffc0\006\uffc0\007\uffc0\012" +
    "\uffc0\013\uffc0\014\uffc0\016\uffc0\025\uffc0\026\uffc0\001\002" +
    "\000\024\004\067\006\061\010\071\012\064\013\060\014" +
    "\056\016\053\025\041\026\uffcf\001\002\000\004\026\uffcb" +
    "\001\002\000\024\004\uffc3\006\uffc3\007\uffc3\012\uffc3\013" +
    "\uffc3\014\uffc3\016\uffc3\025\uffc3\026\uffc3\001\002\000\004" +
    "\021\221\001\002\000\024\004\uffc6\006\uffc6\007\uffc6\012" +
    "\uffc6\013\uffc6\014\uffc6\016\uffc6\025\uffc6\026\uffc6\001\002" +
    "\000\022\004\165\006\061\012\064\013\060\014\056\016" +
    "\053\025\041\026\uffca\001\002\000\012\004\151\020\132" +
    "\021\133\030\215\001\002\000\004\026\uffd1\001\002\000" +
    "\004\021\207\001\002\000\004\021\174\001\002\000\004" +
    "\030\173\001\002\000\004\026\172\001\002\000\004\021" +
    "\166\001\002\000\022\004\165\006\061\012\064\013\060" +
    "\014\056\016\053\025\041\026\uffc8\001\002\000\004\030" +
    "\163\001\002\000\012\004\030\021\115\023\112\035\113" +
    "\001\002\000\024\004\uffc5\006\uffc5\007\uffc5\012\uffc5\013" +
    "\uffc5\014\uffc5\016\uffc5\025\uffc5\026\uffc5\001\002\000\004" +
    "\004\076\001\002\000\024\004\067\006\061\010\074\012" +
    "\064\013\060\014\056\016\053\025\041\026\uffcc\001\002" +
    "\000\004\026\uffcd\001\002\000\004\004\075\001\002\000" +
    "\010\027\uffe8\030\uffe8\035\034\001\002\000\012\023\077" +
    "\027\uffe8\030\uffe8\035\034\001\002\000\006\004\105\020" +
    "\104\001\002\000\004\023\077\001\002\000\004\030\ufff1" +
    "\001\002\000\004\030\103\001\002\000\026\004\ufff0\006" +
    "\ufff0\010\ufff0\012\ufff0\013\ufff0\014\ufff0\015\ufff0\016\ufff0" +
    "\025\ufff0\026\ufff0\001\002\000\004\024\uffef\001\002\000" +
    "\004\024\uffed\001\002\000\004\024\107\001\002\000\006" +
    "\023\uffec\030\uffec\001\002\000\004\024\111\001\002\000" +
    "\006\023\uffee\030\uffee\001\002\000\010\004\151\020\132" +
    "\021\133\001\002\000\010\004\134\020\132\021\133\001" +
    "\002\000\004\023\112\001\002\000\006\004\121\022\117" +
    "\001\002\000\020\022\uffb2\024\uffb2\030\uffb2\031\uffb2\032" +
    "\uffb2\033\uffb2\034\uffb2\001\002\000\020\022\uffb1\024\uffb1" +
    "\030\uffb1\031\uffb1\032\uffb1\033\uffb1\034\uffb1\001\002\000" +
    "\006\022\126\027\125\001\002\000\010\022\uffad\023\112" +
    "\027\uffad\001\002\000\006\022\uffaf\027\uffaf\001\002\000" +
    "\004\023\112\001\002\000\006\022\uffac\027\uffac\001\002" +
    "\000\004\004\121\001\002\000\020\022\uffb0\024\uffb0\030" +
    "\uffb0\031\uffb0\032\uffb0\033\uffb0\034\uffb0\001\002\000\006" +
    "\022\uffae\027\uffae\001\002\000\004\035\131\001\002\000" +
    "\010\004\134\020\132\021\133\001\002\000\020\022\uffbd" +
    "\024\uffbd\030\uffbd\031\uffbd\032\uffbd\033\uffbd\034\uffbd\001" +
    "\002\000\010\004\151\020\132\021\133\001\002\000\024" +
    "\021\115\022\uffbc\023\112\024\uffbc\030\uffbc\031\uffbc\032" +
    "\uffbc\033\uffbc\034\uffbc\001\002\000\020\022\uffba\024\uffba" +
    "\030\uffba\031\uffba\032\uffba\033\uffba\034\uffba\001\002\000" +
    "\020\022\uffbe\024\uffbe\030\uffbe\031\137\032\142\033\141" +
    "\034\140\001\002\000\010\004\134\020\132\021\133\001" +
    "\002\000\010\004\134\020\132\021\133\001\002\000\010" +
    "\004\134\020\132\021\133\001\002\000\010\004\134\020" +
    "\132\021\133\001\002\000\020\022\uffb8\024\uffb8\030\uffb8" +
    "\031\137\032\uffb8\033\uffb8\034\uffb8\001\002\000\020\022" +
    "\uffb7\024\uffb7\030\uffb7\031\137\032\142\033\uffb7\034\uffb7" +
    "\001\002\000\020\022\uffb6\024\uffb6\030\uffb6\031\137\032" +
    "\142\033\141\034\uffb6\001\002\000\020\022\uffb9\024\uffb9" +
    "\030\uffb9\031\uffb9\032\uffb9\033\uffb9\034\uffb9\001\002\000" +
    "\004\023\112\001\002\000\020\022\uffbb\024\uffbb\030\uffbb" +
    "\031\uffbb\032\uffbb\033\uffbb\034\uffbb\001\002\000\026\021" +
    "\115\022\uffbc\023\112\024\uffbc\030\uffbc\031\uffbc\032\uffbc" +
    "\033\uffbc\034\uffbc\035\113\001\002\000\020\022\uffb4\024" +
    "\uffb4\030\uffb4\031\137\032\142\033\141\034\140\001\002" +
    "\000\010\022\uffb3\024\uffb3\030\uffb3\001\002\000\004\022" +
    "\155\001\002\000\020\022\uffb5\024\uffb5\030\uffb5\031\uffb5" +
    "\032\uffb5\033\uffb5\034\uffb5\001\002\000\004\023\112\001" +
    "\002\000\022\022\uffbb\024\uffbb\030\uffbb\031\uffbb\032\uffbb" +
    "\033\uffbb\034\uffbb\035\131\001\002\000\020\022\uffbf\024" +
    "\uffbf\030\uffbf\031\137\032\142\033\141\034\140\001\002" +
    "\000\004\024\162\001\002\000\026\022\uffeb\023\uffeb\024" +
    "\uffeb\027\uffeb\030\uffeb\031\uffeb\032\uffeb\033\uffeb\034\uffeb" +
    "\035\uffeb\001\002\000\024\004\uffc1\006\uffc1\007\uffc1\012" +
    "\uffc1\013\uffc1\014\uffc1\016\uffc1\025\uffc1\026\uffc1\001\002" +
    "\000\004\026\uffc7\001\002\000\010\021\115\023\112\035" +
    "\113\001\002\000\004\017\167\001\002\000\004\022\170" +
    "\001\002\000\004\030\171\001\002\000\024\004\uffa1\006" +
    "\uffa1\007\uffa1\012\uffa1\013\uffa1\014\uffa1\016\uffa1\025\uffa1" +
    "\026\uffa1\001\002\000\032\002\uffd2\004\uffd2\006\uffd2\007" +
    "\uffd2\010\uffd2\012\uffd2\013\uffd2\014\uffd2\015\uffd2\016\uffd2" +
    "\025\uffd2\026\uffd2\001\002\000\024\004\uffc2\006\uffc2\007" +
    "\uffc2\012\uffc2\013\uffc2\014\uffc2\016\uffc2\025\uffc2\026\uffc2" +
    "\001\002\000\010\004\151\020\132\021\133\001\002\000" +
    "\004\022\176\001\002\000\020\004\165\006\061\012\064" +
    "\013\060\014\056\016\053\025\041\001\002\000\024\004" +
    "\uffab\006\uffab\007\204\012\uffab\013\uffab\014\uffab\016\uffab" +
    "\025\uffab\026\uffab\001\002\000\024\004\uffaa\006\uffaa\007" +
    "\201\012\uffaa\013\uffaa\014\uffaa\016\uffaa\025\uffaa\026\uffaa" +
    "\001\002\000\020\004\165\006\061\012\064\013\060\014" +
    "\056\016\053\025\041\001\002\000\024\004\uffa7\006\uffa7" +
    "\007\uffa7\012\uffa7\013\uffa7\014\uffa7\016\uffa7\025\uffa7\026" +
    "\uffa7\001\002\000\024\004\uffa6\006\uffa6\007\uffa6\012\uffa6" +
    "\013\uffa6\014\uffa6\016\uffa6\025\uffa6\026\uffa6\001\002\000" +
    "\020\004\165\006\061\012\064\013\060\014\056\016\053" +
    "\025\041\001\002\000\024\004\uffa9\006\uffa9\007\uffa9\012" +
    "\uffa9\013\uffa9\014\uffa9\016\uffa9\025\uffa9\026\uffa9\001\002" +
    "\000\024\004\uffa8\006\uffa8\007\uffa8\012\uffa8\013\uffa8\014" +
    "\uffa8\016\uffa8\025\uffa8\026\uffa8\001\002\000\012\004\151" +
    "\020\132\021\133\022\210\001\002\000\004\030\214\001" +
    "\002\000\004\022\212\001\002\000\004\030\213\001\002" +
    "\000\024\004\uffa3\006\uffa3\007\uffa3\012\uffa3\013\uffa3\014" +
    "\uffa3\016\uffa3\025\uffa3\026\uffa3\001\002\000\024\004\uffa2" +
    "\006\uffa2\007\uffa2\012\uffa2\013\uffa2\014\uffa2\016\uffa2\025" +
    "\uffa2\026\uffa2\001\002\000\024\004\uff9f\006\uff9f\007\uff9f" +
    "\012\uff9f\013\uff9f\014\uff9f\016\uff9f\025\uff9f\026\uff9f\001" +
    "\002\000\004\030\217\001\002\000\024\004\uffa0\006\uffa0" +
    "\007\uffa0\012\uffa0\013\uffa0\014\uffa0\016\uffa0\025\uffa0\026" +
    "\uffa0\001\002\000\004\026\uffc9\001\002\000\010\004\151" +
    "\020\132\021\133\001\002\000\004\022\223\001\002\000" +
    "\020\004\165\006\061\012\064\013\060\014\056\016\053" +
    "\025\041\001\002\000\024\004\uffa5\006\uffa5\007\uffa5\012" +
    "\uffa5\013\uffa5\014\uffa5\016\uffa5\025\uffa5\026\uffa5\001\002" +
    "\000\024\004\uffa4\006\uffa4\007\uffa4\012\uffa4\013\uffa4\014" +
    "\uffa4\016\uffa4\025\uffa4\026\uffa4\001\002\000\004\026\uffd0" +
    "\001\002\000\004\025\uffdc\001\002\000\004\036\uffd6\001" +
    "\002\000\004\036\242\001\002\000\006\022\uffdb\027\234" +
    "\001\002\000\004\036\uffd7\001\002\000\006\004\230\010" +
    "\233\001\002\000\004\022\236\001\002\000\004\025\uffda" +
    "\001\002\000\004\036\240\001\002\000\004\004\241\001" +
    "\002\000\006\022\uffd8\027\uffd8\001\002\000\004\004\243" +
    "\001\002\000\006\022\uffd9\027\uffd9\001\002\000\006\027" +
    "\uffe7\030\uffe7\001\002\000\006\027\uffe6\030\uffe6\001\002" +
    "\000\004\004\250\001\002\000\004\002\ufff5\001\002\000" +
    "\004\021\uffe0\001\002\000\004\004\253\001\002\000\026" +
    "\004\uffea\006\uffea\010\uffea\012\uffea\013\uffea\014\uffea\015" +
    "\uffea\016\uffea\025\uffea\026\uffea\001\002\000\010\027\uffe5" +
    "\030\uffe5\035\254\001\002\000\006\004\256\020\255\001" +
    "\002\000\006\027\uffe4\030\uffe4\001\002\000\006\027\uffe3" +
    "\030\uffe3\001\002\000\004\004\261\001\002\000\026\004" +
    "\uffe9\006\uffe9\010\uffe9\012\uffe9\013\uffe9\014\uffe9\015\uffe9" +
    "\016\uffe9\025\uffe9\026\uffe9\001\002\000\006\027\uffe1\030" +
    "\uffe1\001\002\000\004\021\036\001\002\000\004\021\264" +
    "\001\002\000\004\022\265\001\002\000\004\025\041\001" +
    "\002\000\004\002\uffdd\001\002\000\004\025\041\001\002" +
    "\000\006\010\uffde\015\uffde\001\002\000\014\021\uffe0\023" +
    "\077\027\uffe8\030\uffe8\035\034\001\002\000\012\004\025" +
    "\005\010\010\012\015\014\001\002\000\004\002\ufffb\001" +
    "\002\000\004\020\275\001\002\000\004\030\ufff3\001\002" +
    "\000\004\030\277\001\002\000\012\004\ufff2\005\ufff2\010" +
    "\ufff2\015\ufff2\001\002\000\004\002\001\001\002" });

  /** Access to parse-action table. */
  public short[][] action_table() {return _action_table;}

  /** <code>reduce_goto</code> table. */
  protected static final short[][] _reduce_table = 
    unpackFromStrings(new String[] {
    "\000\276\000\006\002\003\052\004\001\001\000\002\001" +
    "\001\000\006\045\006\053\005\001\001\000\030\003\022" +
    "\004\017\005\012\006\021\007\016\010\010\012\025\014" +
    "\023\017\015\020\014\021\020\001\001\000\002\001\001" +
    "\000\002\001\001\000\004\054\271\001\001\000\002\001" +
    "\001\000\002\001\001\000\002\001\001\000\002\001\001" +
    "\000\002\001\001\000\002\001\001\000\002\001\001\000" +
    "\010\006\246\007\016\021\020\001\001\000\002\001\001" +
    "\000\002\001\001\000\020\005\031\006\021\007\016\014" +
    "\023\017\015\020\014\021\020\001\001\000\002\001\001" +
    "\000\024\004\026\005\012\006\021\007\016\012\025\014" +
    "\023\017\015\020\014\021\020\001\001\000\002\001\001" +
    "\000\002\001\001\000\002\001\001\000\002\001\001\000" +
    "\004\061\034\001\001\000\002\001\001\000\004\023\036" +
    "\001\001\000\006\022\230\024\231\001\001\000\004\035" +
    "\037\001\001\000\002\001\001\000\006\063\042\064\041" +
    "\001\001\000\044\011\056\012\047\013\045\014\071\017" +
    "\015\020\014\026\061\030\065\034\046\035\054\036\062" +
    "\037\050\040\064\041\053\042\067\043\044\044\051\001" +
    "\001\000\002\001\001\000\002\001\001\000\002\001\001" +
    "\000\002\001\001\000\002\001\001\000\042\011\225\012" +
    "\047\013\045\014\071\017\015\020\014\026\061\030\065" +
    "\034\046\035\054\037\050\040\064\041\053\042\067\043" +
    "\044\044\051\001\001\000\002\001\001\000\002\001\001" +
    "\000\002\001\001\000\002\001\001\000\026\026\061\030" +
    "\065\034\046\035\054\037\217\040\064\041\053\042\067" +
    "\043\044\044\051\001\001\000\012\025\215\026\152\027" +
    "\151\030\134\001\001\000\002\001\001\000\002\001\001" +
    "\000\002\001\001\000\002\001\001\000\002\001\001\000" +
    "\002\001\001\000\026\026\061\030\065\034\046\035\054" +
    "\037\163\040\064\041\053\042\067\043\044\044\051\001" +
    "\001\000\002\001\001\000\006\016\113\031\115\001\001" +
    "\000\002\001\001\000\002\001\001\000\036\013\072\014" +
    "\071\017\015\020\014\026\061\030\065\034\046\035\054" +
    "\037\050\040\064\041\053\042\067\043\044\044\051\001" +
    "\001\000\002\001\001\000\002\001\001\000\002\001\001" +
    "\000\004\015\077\001\001\000\002\001\001\000\004\015" +
    "\100\001\001\000\004\056\101\001\001\000\002\001\001" +
    "\000\002\001\001\000\004\057\107\001\001\000\004\060" +
    "\105\001\001\000\002\001\001\000\002\001\001\000\002" +
    "\001\001\000\002\001\001\000\012\025\160\026\152\027" +
    "\151\030\134\001\001\000\006\027\157\030\134\001\001" +
    "\000\004\016\127\001\001\000\006\032\117\033\121\001" +
    "\001\000\002\001\001\000\002\001\001\000\002\001\001" +
    "\000\004\016\122\001\001\000\002\001\001\000\004\016" +
    "\123\001\001\000\002\001\001\000\004\033\126\001\001" +
    "\000\002\001\001\000\002\001\001\000\002\001\001\000" +
    "\006\027\135\030\134\001\001\000\002\001\001\000\012" +
    "\025\153\026\152\027\151\030\134\001\001\000\006\016" +
    "\146\031\115\001\001\000\002\001\001\000\002\001\001" +
    "\000\006\027\145\030\134\001\001\000\006\027\144\030" +
    "\134\001\001\000\006\027\143\030\134\001\001\000\006" +
    "\027\142\030\134\001\001\000\002\001\001\000\002\001" +
    "\001\000\002\001\001\000\002\001\001\000\004\016\147" +
    "\001\001\000\002\001\001\000\006\016\155\031\115\001" +
    "\001\000\002\001\001\000\002\001\001\000\002\001\001" +
    "\000\002\001\001\000\004\016\156\001\001\000\002\001" +
    "\001\000\002\001\001\000\002\001\001\000\002\001\001" +
    "\000\002\001\001\000\002\001\001\000\006\016\113\031" +
    "\115\001\001\000\002\001\001\000\002\001\001\000\002" +
    "\001\001\000\002\001\001\000\002\001\001\000\002\001" +
    "\001\000\012\025\174\026\152\027\151\030\134\001\001" +
    "\000\002\001\001\000\024\026\061\030\065\034\046\035" +
    "\177\040\176\041\053\042\067\043\044\044\051\001\001" +
    "\000\002\001\001\000\002\001\001\000\024\026\061\030" +
    "\065\034\046\035\202\040\201\041\053\042\067\043\044" +
    "\044\051\001\001\000\002\001\001\000\002\001\001\000" +
    "\024\026\061\030\065\034\046\035\205\040\204\041\053" +
    "\042\067\043\044\044\051\001\001\000\002\001\001\000" +
    "\002\001\001\000\012\025\210\026\152\027\151\030\134" +
    "\001\001\000\002\001\001\000\002\001\001\000\002\001" +
    "\001\000\002\001\001\000\002\001\001\000\002\001\001" +
    "\000\002\001\001\000\002\001\001\000\002\001\001\000" +
    "\012\025\221\026\152\027\151\030\134\001\001\000\002" +
    "\001\001\000\024\026\061\030\065\034\046\035\224\040" +
    "\223\041\053\042\067\043\044\044\051\001\001\000\002" +
    "\001\001\000\002\001\001\000\002\001\001\000\002\001" +
    "\001\000\002\001\001\000\002\001\001\000\004\062\234" +
    "\001\001\000\002\001\001\000\004\022\236\001\001\000" +
    "\002\001\001\000\002\001\001\000\002\001\001\000\002" +
    "\001\001\000\002\001\001\000\002\001\001\000\002\001" +
    "\001\000\002\001\001\000\002\001\001\000\002\001\001" +
    "\000\002\001\001\000\004\061\034\001\001\000\002\001" +
    "\001\000\002\001\001\000\002\001\001\000\002\001\001" +
    "\000\002\001\001\000\002\001\001\000\002\001\001\000" +
    "\002\001\001\000\002\001\001\000\004\023\266\001\001" +
    "\000\002\001\001\000\002\001\001\000\004\035\265\001" +
    "\001\000\002\001\001\000\004\035\267\001\001\000\002" +
    "\001\001\000\006\015\077\061\034\001\001\000\030\003" +
    "\272\004\017\005\012\006\021\007\016\010\010\012\025" +
    "\014\023\017\015\020\014\021\020\001\001\000\002\001" +
    "\001\000\002\001\001\000\004\055\275\001\001\000\002" +
    "\001\001\000\002\001\001\000\002\001\001" });

  /** Access to <code>reduce_goto</code> table. */
  public short[][] reduce_table() {return _reduce_table;}

  /** Instance of action encapsulation class. */
  protected CUP$parser$actions action_obj;

  /** Action encapsulation object initializer. */
  protected void init_actions()
    {
      action_obj = new CUP$parser$actions(this);
    }

  /** Invoke a user supplied parse action. */
  public java_cup.runtime.Symbol do_action(
    int                        act_num,
    java_cup.runtime.lr_parser parser,
    java.util.Stack            stack,
    int                        top)
    throws java.lang.Exception
  {
    /* call code in generated class */
    return action_obj.CUP$parser$do_action(act_num, parser, stack, top);
  }

  /** Indicates start state. */
  public int start_state() {return 0;}
  /** Indicates start production. */
  public int start_production() {return 0;}

  /** <code>EOF</code> Symbol index. */
  public int EOF_sym() {return 0;}

  /** <code>error</code> Symbol index. */
  public int error_sym() {return 1;}



	SyntaxErrorManager        syntaxErrorManager   = CompilerContext.getSyntaxErrorManager();
	
	
	public void syntax_error(Symbol symbol)
	{

	    Token token = (Token) symbol.value;
	    syntaxErrorManager.syntaxError ("Error sintactico", token);	    
	}
		
	public void unrecovered_syntax_error(java_cup.runtime.Symbol symbol)
	{	
	    Token token = (Token) symbol.value;
	    syntaxErrorManager.syntaxFatalError ("Error fatal", token);
	    
	}

}

/** Cup generated class to encapsulate user supplied action code.*/
class CUP$parser$actions {


	
	SyntaxErrorManager        syntaxErrorManager   = CompilerContext.getSyntaxErrorManager();
	SemanticErrorManager      semanticErrorManager = CompilerContext.getSemanticErrorManager ();
	ScopeManagerIF            scopeManager         = CompilerContext.getScopeManager ();
	FinalCodeFactoryIF        finalCodeFactory     = CompilerContext.getFinalCodeFactory ();


  private final parser parser;

  /** Constructor */
  CUP$parser$actions(parser parser) {
    this.parser = parser;
  }

  /** Method with the actual generated action code. */
  public final java_cup.runtime.Symbol CUP$parser$do_action(
    int                        CUP$parser$act_num,
    java_cup.runtime.lr_parser CUP$parser$parser,
    java.util.Stack            CUP$parser$stack,
    int                        CUP$parser$top)
    throws java.lang.Exception
    {
      /* Symbol object for return from actions */
      java_cup.runtime.Symbol CUP$parser$result;

      /* select the action based on the action number */
      switch (CUP$parser$act_num)
        {
          /*. . . . . . . . . . . . . . . . . . . .*/
          case 98: // retorno_funcion ::= RETURN PUNTOYCOMA 
            {
              Object RESULT =null;

              CUP$parser$result = parser.getSymbolFactory().newSymbol("retorno_funcion",26, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 97: // retorno_funcion ::= RETURN expresion PUNTOYCOMA 
            {
              Object RESULT =null;
		int exleft = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)).left;
		int exright = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)).right;
		Object ex = (Object)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-1)).value;
		 
	
					Expresion expresion = (Expresion)ex;
					Sentencia_simple simple = new Sentencia_simple();
					simple.setEx(expresion);
					simple.setTipo("return");
					RESULT = simple;
						
              CUP$parser$result = parser.getSymbolFactory().newSymbol("retorno_funcion",26, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 96: // sentencia_printc ::= PRINTC PARIZQ CADENA PARDER PUNTOYCOMA 
            {
              Object RESULT =null;
		int cadenaleft = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)).left;
		int cadenaright = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)).right;
		Token cadena = (Token)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-2)).value;
		 
					Sentencia_printc printc = new Sentencia_printc(cadena.getLexema());
					RESULT = printc;
	
	
              CUP$parser$result = parser.getSymbolFactory().newSymbol("sentencia_printc",34, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-4)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 95: // sentencia_printi ::= PRINTI PARIZQ PARDER PUNTOYCOMA 
            {
              Object RESULT =null;

              CUP$parser$result = parser.getSymbolFactory().newSymbol("sentencia_printi",33, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-3)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 94: // sentencia_printi ::= PRINTI PARIZQ expresion PARDER PUNTOYCOMA 
            {
              Object RESULT =null;
		int exleft = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)).left;
		int exright = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)).right;
		Object ex = (Object)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-2)).value;
		
						Expresion expresion = (Expresion)ex;
						Sentencia_simple simple = new Sentencia_simple();
						simple.setEx(expresion);
						simple.setTipo("printi");
						RESULT = simple;
	
	
              CUP$parser$result = parser.getSymbolFactory().newSymbol("sentencia_printi",33, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-4)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 93: // sentencia_while ::= WHILE PARIZQ expresion PARDER bloque_sentencias 
            {
              Object RESULT =null;
		int pleft = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-3)).left;
		int pright = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-3)).right;
		Token p = (Token)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-3)).value;
		int exleft = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)).left;
		int exright = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)).right;
		Object ex = (Object)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-2)).value;
		int bloqueleft = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).left;
		int bloqueright = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).right;
		Object bloque = (Object)((java_cup.runtime.Symbol) CUP$parser$stack.peek()).value;
		
						
						Expresion expresion = (Expresion)ex;

					if (expresion.getValor()==0 || expresion.getValor()==1) {
						Sentencia_While sWhile = new Sentencia_While();
						sWhile.setS1((Bloque_sentencias)bloque);
						RESULT = sWhile;
					}

					else
						semanticErrorManager.semanticFatalError("Error. Se esperaba una expresion logica en la linea " + p.getLine());
					
					
					
              CUP$parser$result = parser.getSymbolFactory().newSymbol("sentencia_while",32, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-4)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 92: // sentencia_while ::= WHILE PARIZQ expresion PARDER sentencia 
            {
              Object RESULT =null;
		int pleft = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-3)).left;
		int pright = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-3)).right;
		Token p = (Token)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-3)).value;
		int exleft = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)).left;
		int exright = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)).right;
		Object ex = (Object)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-2)).value;
		int senleft = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).left;
		int senright = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).right;
		Object sen = (Object)((java_cup.runtime.Symbol) CUP$parser$stack.peek()).value;
		
	

	Expresion expresion = (Expresion)ex;

	if (expresion.getValor()==0 || expresion.getValor()==1) {
		Sentencia_While sWhile = new Sentencia_While();
		sWhile.setS1((Bloque_sentencias)sen);
		RESULT = sWhile;
	}

	else
		semanticErrorManager.semanticFatalError("Error. Se esperaba una expresion logica en la linea " + p.getLine());





              CUP$parser$result = parser.getSymbolFactory().newSymbol("sentencia_while",32, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-4)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 91: // sentencia_if ::= IF PARIZQ expresion PARDER bloque_sentencias ELSE bloque_sentencias 
            {
              Object RESULT =null;
		int pleft = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-5)).left;
		int pright = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-5)).right;
		Token p = (Token)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-5)).value;
		int exleft = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-4)).left;
		int exright = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-4)).right;
		Object ex = (Object)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-4)).value;
		int bloque1left = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)).left;
		int bloque1right = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)).right;
		Object bloque1 = (Object)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-2)).value;
		int bloque2left = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).left;
		int bloque2right = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).right;
		Object bloque2 = (Object)((java_cup.runtime.Symbol) CUP$parser$stack.peek()).value;
		
						Expresion expresion = (Expresion)ex;
					
						if (expresion.getValor()==0 || expresion.getValor()==1) {
							SentenciaIF sIF = new SentenciaIF((Expresion)ex, true);
							sIF.setS1((Bloque_sentencias)bloque1);
							sIF.setS2((Bloque_sentencias)bloque1);
							RESULT = sIF;
				}

				else
					semanticErrorManager.semanticFatalError("Error. Se esperaba una expresion logica en la linea " + p.getLine());
					
						
						
						
						
              CUP$parser$result = parser.getSymbolFactory().newSymbol("sentencia_if",31, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-6)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 90: // sentencia_if ::= IF PARIZQ expresion PARDER bloque_sentencias ELSE sentencia 
            {
              Object RESULT =null;
		int pleft = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-5)).left;
		int pright = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-5)).right;
		Token p = (Token)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-5)).value;
		int exleft = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-4)).left;
		int exright = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-4)).right;
		Object ex = (Object)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-4)).value;
		int bloqueleft = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)).left;
		int bloqueright = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)).right;
		Object bloque = (Object)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-2)).value;
		int senleft = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).left;
		int senright = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).right;
		Object sen = (Object)((java_cup.runtime.Symbol) CUP$parser$stack.peek()).value;
		
						Expresion expresion = (Expresion)ex;
					
						if (expresion.getValor()==0 || expresion.getValor()==1) {
							SentenciaIF sIF = new SentenciaIF((Expresion)ex, true);
							sIF.setS1((Bloque_sentencias)bloque);
							sIF.setS2((Bloque_sentencias)sen);
							RESULT = sIF;
				}

				else
					semanticErrorManager.semanticFatalError("Error. Se esperaba una expresion logica en la linea " + p.getLine());
					
						
						
						
						
              CUP$parser$result = parser.getSymbolFactory().newSymbol("sentencia_if",31, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-6)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 89: // sentencia_if ::= IF PARIZQ expresion PARDER sentencia ELSE bloque_sentencias 
            {
              Object RESULT =null;
		int pleft = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-5)).left;
		int pright = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-5)).right;
		Token p = (Token)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-5)).value;
		int exleft = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-4)).left;
		int exright = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-4)).right;
		Object ex = (Object)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-4)).value;
		int senleft = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)).left;
		int senright = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)).right;
		Object sen = (Object)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-2)).value;
		int bloqueleft = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).left;
		int bloqueright = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).right;
		Object bloque = (Object)((java_cup.runtime.Symbol) CUP$parser$stack.peek()).value;
		
						Expresion expresion = (Expresion)ex;
				
						if (expresion.getValor()==0 || expresion.getValor()==1) {
							SentenciaIF sIF = new SentenciaIF((Expresion)ex, true);
							sIF.setS1((Bloque_sentencias)sen);
							sIF.setS2((Bloque_sentencias)bloque);
							RESULT = sIF;
					}

					else
						semanticErrorManager.semanticFatalError("Error. Se esperaba una expresion logica en la linea " + p.getLine());
						
						
						
              CUP$parser$result = parser.getSymbolFactory().newSymbol("sentencia_if",31, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-6)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 88: // sentencia_if ::= IF PARIZQ expresion PARDER sentencia ELSE sentencia 
            {
              Object RESULT =null;
		int pleft = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-5)).left;
		int pright = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-5)).right;
		Token p = (Token)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-5)).value;
		int exleft = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-4)).left;
		int exright = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-4)).right;
		Object ex = (Object)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-4)).value;
		int s1left = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)).left;
		int s1right = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)).right;
		Object s1 = (Object)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-2)).value;
		int s2left = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).left;
		int s2right = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).right;
		Object s2 = (Object)((java_cup.runtime.Symbol) CUP$parser$stack.peek()).value;
		
						
						Expresion expresion = (Expresion)ex;
						if (expresion.getValor()==0 || expresion.getValor()==1) {
							SentenciaIF sIF = new SentenciaIF((Expresion)ex, true);
							sIF.setS1((Bloque_sentencias)s1);
							sIF.setS2((Bloque_sentencias)s2);
							RESULT = sIF;
						}
	
						else
							semanticErrorManager.semanticFatalError("Error. Se esperaba una expresion logica en la linea " + p.getLine());

				
				
				
              CUP$parser$result = parser.getSymbolFactory().newSymbol("sentencia_if",31, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-6)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 87: // sentencia_if ::= IF PARIZQ expresion PARDER bloque_sentencias 
            {
              Object RESULT =null;
		int pleft = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-3)).left;
		int pright = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-3)).right;
		Token p = (Token)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-3)).value;
		int exleft = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)).left;
		int exright = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)).right;
		Object ex = (Object)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-2)).value;
		int sleft = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).left;
		int sright = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).right;
		Object s = (Object)((java_cup.runtime.Symbol) CUP$parser$stack.peek()).value;
		
						
					Expresion expresion = (Expresion)ex;	
					if (expresion.getValor()==0 || expresion.getValor()==1) {
	
						SentenciaIF sIF = new SentenciaIF((Expresion)ex, false);
						sIF.setS1((Bloque_sentencias)s);
						RESULT = sIF;
					}
					
					else
						semanticErrorManager.semanticFatalError("Error. Se esperaba una expresion logica en la linea " + p.getLine());
				
				
              CUP$parser$result = parser.getSymbolFactory().newSymbol("sentencia_if",31, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-4)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 86: // sentencia_if ::= IF PARIZQ expresion PARDER sentencia 
            {
              Object RESULT =null;
		int pleft = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-3)).left;
		int pright = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-3)).right;
		Token p = (Token)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-3)).value;
		int exleft = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)).left;
		int exright = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)).right;
		Object ex = (Object)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-2)).value;
		int senleft = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).left;
		int senright = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).right;
		Object sen = (Object)((java_cup.runtime.Symbol) CUP$parser$stack.peek()).value;
		
			Expresion expresion = (Expresion)ex;
			
			if (expresion.getValor()==0 || expresion.getValor()==1) {
				SentenciaIF sIF = new SentenciaIF((Expresion)ex, false);
				sIF.setS1((Bloque_sentencias)sen);
				RESULT = sIF;
			}
			else
				semanticErrorManager.semanticFatalError("Error. Se esperaba una expresion logica en la linea " + p.getLine());

	
	
	
              CUP$parser$result = parser.getSymbolFactory().newSymbol("sentencia_if",31, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-4)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 85: // parametro ::= IDENTIFICADOR rango_matriz rango_matriz 
            {
              Object RESULT =null;

              CUP$parser$result = parser.getSymbolFactory().newSymbol("parametro",25, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 84: // parametro ::= IDENTIFICADOR 
            {
              Object RESULT =null;

              CUP$parser$result = parser.getSymbolFactory().newSymbol("parametro",25, ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 83: // parametros ::= parametros COMA parametro 
            {
              Object RESULT =null;

              CUP$parser$result = parser.getSymbolFactory().newSymbol("parametros",24, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 82: // parametros ::= parametro 
            {
              Object RESULT =null;

              CUP$parser$result = parser.getSymbolFactory().newSymbol("parametros",24, ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 81: // lista_parametros ::= PARIZQ parametros PARDER 
            {
              Object RESULT =null;

              CUP$parser$result = parser.getSymbolFactory().newSymbol("lista_parametros",23, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 80: // lista_parametros ::= PARIZQ PARDER 
            {
              Object RESULT =null;

              CUP$parser$result = parser.getSymbolFactory().newSymbol("lista_parametros",23, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 79: // llamada_funcion ::= IDENTIFICADOR lista_parametros 
            {
              Object RESULT =null;

              CUP$parser$result = parser.getSymbolFactory().newSymbol("llamada_funcion",22, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 78: // expresion ::= asignacion 
            {
              Object RESULT =null;
		int asigleft = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).left;
		int asigright = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).right;
		Object asig = (Object)((java_cup.runtime.Symbol) CUP$parser$stack.peek()).value;
		
					RESULT=asig;
					
					
              CUP$parser$result = parser.getSymbolFactory().newSymbol("expresion",19, ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 77: // expresion ::= expresion_sin_asign 
            {
              Object RESULT =null;
		int exleft = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).left;
		int exright = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).right;
		Object ex = (Object)((java_cup.runtime.Symbol) CUP$parser$stack.peek()).value;
		 
		
			RESULT=ex;
		
			
	
              CUP$parser$result = parser.getSymbolFactory().newSymbol("expresion",19, ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 76: // expresion_sin_asign ::= PARIZQ expresion PARDER 
            {
              Object RESULT =null;
		int expleft = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)).left;
		int expright = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)).right;
		Object exp = (Object)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-1)).value;
		
							RESULT= exp;
							
              CUP$parser$result = parser.getSymbolFactory().newSymbol("expresion_sin_asign",21, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 75: // expresion_sin_asign ::= expresion_sin_asign AND expresion_sin_asign 
            {
              Object RESULT =null;
		int ex1left = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)).left;
		int ex1right = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)).right;
		Object ex1 = (Object)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-2)).value;
		int aleft = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)).left;
		int aright = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)).right;
		Token a = (Token)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-1)).value;
		int ex2left = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).left;
		int ex2right = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).right;
		Object ex2 = (Object)((java_cup.runtime.Symbol) CUP$parser$stack.peek()).value;
		
						
							Expresion exp1 = (Expresion)ex1;
							Expresion exp2 = (Expresion)ex2;
							int valor;
							boolean valor1=false;
							boolean valor2=false;
							
							if (exp1.getValor()==1)
								valor1 = true;
							else {
								if (exp1.getValor()==0)
									valor1 = false;
								else
									semanticErrorManager.semanticFatalError("Error. El valor " + exp1.getValor() + " no es un valor lógico en la linea " + a.getLine());
								}
							
							if (exp2.getValor()==1)
								valor2 = true;
							else {
								if (exp2.getValor()==0)
									valor2 = false;
								else
									semanticErrorManager.semanticFatalError("Error. El valor " + exp2.getValor() + " no es un valor lógico en la linea " + a.getLine());
								}
							
							
							if (valor1 && valor2)
								valor=1;
							else
								valor=0;
							
							ExpresionCompuesta expCompuesta = new ExpresionCompuesta(valor, "tipoCompuesto",(Expresion) ex1,(Expresion) ex2);
						
					
							RESULT = expCompuesta;
							
							
              CUP$parser$result = parser.getSymbolFactory().newSymbol("expresion_sin_asign",21, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 74: // expresion_sin_asign ::= expresion_sin_asign DISTINTO expresion_sin_asign 
            {
              Object RESULT =null;
		int ex1left = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)).left;
		int ex1right = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)).right;
		Object ex1 = (Object)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-2)).value;
		int ex2left = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).left;
		int ex2right = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).right;
		Object ex2 = (Object)((java_cup.runtime.Symbol) CUP$parser$stack.peek()).value;
		
							
							Expresion exp1 = (Expresion)ex1;
							Expresion exp2 = (Expresion)ex2;
							int valor;
							if (exp1.getValor() != exp2.getValor())
								valor=1;
							else
								valor=0;
							ExpresionCompuesta expCompuesta = new ExpresionCompuesta(valor,"tipoCompuesto", (Expresion)ex1,(Expresion)ex2);
							
						
							RESULT = expCompuesta;
						
							
							
							
              CUP$parser$result = parser.getSymbolFactory().newSymbol("expresion_sin_asign",21, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 73: // expresion_sin_asign ::= expresion_sin_asign MENOR expresion_sin_asign 
            {
              Object RESULT =null;
		int ex1left = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)).left;
		int ex1right = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)).right;
		Object ex1 = (Object)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-2)).value;
		int ex2left = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).left;
		int ex2right = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).right;
		Object ex2 = (Object)((java_cup.runtime.Symbol) CUP$parser$stack.peek()).value;
		
						
							Expresion exp1 = (Expresion)ex1;
							Expresion exp2 = (Expresion)ex2;
							int valor;
							if (exp1.getValor() < exp2.getValor())
								valor=1;
							else
								valor=0;
							ExpresionCompuesta expCompuesta = new ExpresionCompuesta(valor,"tipoCompuesto", (Expresion)ex1, (Expresion)ex2);
							
							
							RESULT = expCompuesta;
						
							
              CUP$parser$result = parser.getSymbolFactory().newSymbol("expresion_sin_asign",21, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 72: // expresion_sin_asign ::= expresion_sin_asign MAS expresion_sin_asign 
            {
              Object RESULT =null;
		int ex1left = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)).left;
		int ex1right = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)).right;
		Object ex1 = (Object)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-2)).value;
		int masleft = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)).left;
		int masright = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)).right;
		Token mas = (Token)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-1)).value;
		int ex2left = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).left;
		int ex2right = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).right;
		Object ex2 = (Object)((java_cup.runtime.Symbol) CUP$parser$stack.peek()).value;
		
							Expresion exp1 = (Expresion)ex1;
 							Expresion exp2 = (Expresion)ex2;
							ExpresionCompuesta expCompuesta = new ExpresionCompuesta(exp1.getValor()+exp2.getValor(),"tipoCompuesto", (Expresion)ex1, (Expresion)ex2);
 							
								
								RESULT= expCompuesta;
					
							
							
							
              CUP$parser$result = parser.getSymbolFactory().newSymbol("expresion_sin_asign",21, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 71: // expresion_sin_asign ::= llamada_funcion 
            {
              Object RESULT =null;

              CUP$parser$result = parser.getSymbolFactory().newSymbol("expresion_sin_asign",21, ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 70: // expresion_sin_asign ::= IDENTIFICADOR rango_matriz rango_matriz 
            {
              Object RESULT =null;
		int idleft = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)).left;
		int idright = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)).right;
		Token id = (Token)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-2)).value;
		int r1left = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)).left;
		int r1right = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)).right;
		Object r1 = (Object)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-1)).value;
		int r2left = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).left;
		int r2right = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).right;
		Object r2 = (Object)((java_cup.runtime.Symbol) CUP$parser$stack.peek()).value;
		
							ScopeIF sc = scopeManager.getCurrentScope();
 							SymbolTableIF ts = sc.getSymbolTable();
 							if (scopeManager.containsSymbol(id.getLexema())) {
 								SymbolMatrix sMatrix = (SymbolMatrix)scopeManager.searchSymbol(id.getLexema());
 								if (sMatrix.rangoCorrecto((int)r1,(int)r2)) {
 									if (sMatrix.getDefinido((int)r1,(int)r2)) {
 										ExpresionMatriz expMatriz = new ExpresionMatriz(sMatrix.getValor((int)r1,(int)r2),id.getLexema(),(int)r1,(int)r2);
 										RESULT= expMatriz;
 									}
 									else
 	 									semanticErrorManager.semanticFatalError("Error. La posicion [" + (int)r1 + "][" + (int)r2 + "] de la matriz "+ id.getLexema() + " no esta definida en la linea " + id.getLine());

 									
 								
 								}
 								else
 									semanticErrorManager.semanticFatalError("Error. La matriz " + id.getLexema() + " esta fuera de rango en la linea " + id.getLine());
 							
 							}	
 						
 							else {
 								semanticErrorManager.semanticFatalError("Error. La matriz " + id.getLexema() + " no ha sido declarada en la linea " + id.getLine());
 							}
 						
							
							
							
              CUP$parser$result = parser.getSymbolFactory().newSymbol("expresion_sin_asign",21, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 69: // expresion_sin_asign ::= IDENTIFICADOR 
            {
              Object RESULT =null;
		int idleft = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).left;
		int idright = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).right;
		Token id = (Token)((java_cup.runtime.Symbol) CUP$parser$stack.peek()).value;
		
							ScopeIF sc = scopeManager.getCurrentScope();
 							SymbolTableIF ts = sc.getSymbolTable();
 						if (scopeManager.containsSymbol(id.getLexema())) {
 							SymbolIF simbolo = scopeManager.searchSymbol(id.getLexema());
 							if (((simbolo.getType()).getName()).equals("Entero")) {
 								if (simbolo instanceof SymbolVariable) {
 									 ExpresionId expId = new ExpresionId(((SymbolVariable)simbolo).getValor(),id.getLexema());
 									 RESULT = expId;
 								}

								else {
									 ExpresionId expId = new ExpresionId(((SymbolConstant)simbolo).getValor(),id.getLexema());
 									 RESULT = expId;

								}
 							}
 							else
 									semanticErrorManager.semanticFatalError("Error. Identificador no válido " + id.getLexema() + " en la linea " + id.getLine());
 									
								
							
 						}
 						
 						else
 							semanticErrorManager.semanticFatalError("Error. Identificador " + id.getLexema() + " no encontrado en la linea " + id.getLine());
							
              CUP$parser$result = parser.getSymbolFactory().newSymbol("expresion_sin_asign",21, ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 68: // expresion_sin_asign ::= NUMERO 
            {
              Object RESULT =null;
		int numleft = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).left;
		int numright = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).right;
		Token num = (Token)((java_cup.runtime.Symbol) CUP$parser$stack.peek()).value;
		
			if (TypeSimple.rangoCorrecto(Integer.parseInt(num.getLexema()))){
				Expresion exp = new Expresion(Integer.parseInt(num.getLexema()),"tipoEntero");
				RESULT= exp;
				}
			else
				semanticErrorManager.semanticFatalError("Error. El número " + num.getLexema() + " esta fuera de rango en la linea " + num.getLine());

				
				
	
              CUP$parser$result = parser.getSymbolFactory().newSymbol("expresion_sin_asign",21, ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 67: // asignacion ::= IDENTIFICADOR rango_matriz rango_matriz ASIGNACION expresion_sin_asign 
            {
              Object RESULT =null;
		int idleft = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-4)).left;
		int idright = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-4)).right;
		Token id = (Token)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-4)).value;
		int r1left = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-3)).left;
		int r1right = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-3)).right;
		Object r1 = (Object)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-3)).value;
		int r2left = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)).left;
		int r2right = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)).right;
		Object r2 = (Object)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-2)).value;
		int exleft = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).left;
		int exright = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).right;
		Object ex = (Object)((java_cup.runtime.Symbol) CUP$parser$stack.peek()).value;
		
 						
 						ScopeIF sc = scopeManager.getCurrentScope();
 						SymbolTableIF ts = sc.getSymbolTable();
 						if (scopeManager.containsSymbol(id.getLexema())) {
 							SymbolMatrix sMatrix = (SymbolMatrix)scopeManager.searchSymbol(id.getLexema());
 							if (sMatrix.rangoCorrecto((int)r1,(int)r2)) {
 								sMatrix.setValor((int)r1,(int)r2, ((Expresion)ex).getValor());
 								ts.addSymbol(sMatrix);
 								ExpresionMatriz exp1 = new ExpresionMatriz(((Expresion)ex).getValor(),id.getLexema(), (int)r1,(int)r2);
								ExpresionCompuesta expCompuesta = new ExpresionCompuesta(((Expresion)ex).getValor(), "tipoAsignacion", exp1, (Expresion)ex);
								RESULT =expCompuesta;
 								
 							}
 							else
 								semanticErrorManager.semanticFatalError("Error. La matriz " + id.getLexema() + " esta fuera de rango en la linea " + id.getLine());
 							
 						}	
 						
 						else {
 							semanticErrorManager.semanticFatalError("Error. La matriz " + id.getLexema() + " no ha sido declarada en la linea " + id.getLine());
 						}
 						
 						
 						
              CUP$parser$result = parser.getSymbolFactory().newSymbol("asignacion",20, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-4)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 66: // asignacion ::= IDENTIFICADOR ASIGNACION expresion_sin_asign 
            {
              Object RESULT =null;
		int idleft = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)).left;
		int idright = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)).right;
		Token id = (Token)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-2)).value;
		int exleft = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).left;
		int exright = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).right;
		Object ex = (Object)((java_cup.runtime.Symbol) CUP$parser$stack.peek()).value;
		 	
					ScopeIF sc = scopeManager.getCurrentScope();
					SymbolTableIF ts = sc.getSymbolTable();
						if (scopeManager.containsSymbol(id.getLexema())) {
							SymbolIF simbolo = scopeManager.searchSymbol(id.getLexema());
							if (((simbolo.getType()).getName()).equals("Entero")) {
								if (simbolo instanceof SymbolVariable) {
									SymbolVariable sVariable = (SymbolVariable)simbolo;
									sVariable.setValor(((Expresion)ex).getValor());
									ts.addSymbol(sVariable);
									ExpresionId exp1 = new ExpresionId(((Expresion)ex).getValor(),id.getLexema());
									ExpresionCompuesta expCompuesta = new ExpresionCompuesta(((Expresion)ex).getValor(), "tipoAsignacion", exp1, (Expresion)ex);
									
									System.out.println(ts);
									RESULT = expCompuesta; 
								}

								else {
									semanticErrorManager.semanticFatalError("Error. No se puede asignar un valor a la constante " + id.getLexema() + " en la linea " + id.getLine());

								}
							}
							else
								semanticErrorManager.semanticFatalError("Error. Identificador no válido " + id.getLexema() + " en la linea " + id.getLine());
			
	

						}
					
						
              CUP$parser$result = parser.getSymbolFactory().newSymbol("asignacion",20, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 65: // sentencia ::= retorno_funcion 
            {
              Object RESULT =null;
		int senleft = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).left;
		int senright = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).right;
		Object sen = (Object)((java_cup.runtime.Symbol) CUP$parser$stack.peek()).value;
		
				RESULT = sen;
			
			
              CUP$parser$result = parser.getSymbolFactory().newSymbol("sentencia",30, ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 64: // sentencia ::= llamada_funcion PUNTOYCOMA 
            {
              Object RESULT =null;
		int senleft = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).left;
		int senright = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).right;
		Token sen = (Token)((java_cup.runtime.Symbol) CUP$parser$stack.peek()).value;
		
				RESULT = sen;
			
			
              CUP$parser$result = parser.getSymbolFactory().newSymbol("sentencia",30, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 63: // sentencia ::= asignacion PUNTOYCOMA 
            {
              Object RESULT =null;
		int senleft = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).left;
		int senright = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).right;
		Token sen = (Token)((java_cup.runtime.Symbol) CUP$parser$stack.peek()).value;
		
				RESULT = sen;
			
			
              CUP$parser$result = parser.getSymbolFactory().newSymbol("sentencia",30, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 62: // sentencia ::= sentencia_printc 
            {
              Object RESULT =null;
		int senleft = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).left;
		int senright = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).right;
		Object sen = (Object)((java_cup.runtime.Symbol) CUP$parser$stack.peek()).value;
		
				RESULT = sen;
			
			
              CUP$parser$result = parser.getSymbolFactory().newSymbol("sentencia",30, ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 61: // sentencia ::= sentencia_printi 
            {
              Object RESULT =null;
		int senleft = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).left;
		int senright = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).right;
		Object sen = (Object)((java_cup.runtime.Symbol) CUP$parser$stack.peek()).value;
		
				RESULT = sen;
			
			
              CUP$parser$result = parser.getSymbolFactory().newSymbol("sentencia",30, ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 60: // sentencia ::= sentencia_while 
            {
              Object RESULT =null;
		int senleft = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).left;
		int senright = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).right;
		Object sen = (Object)((java_cup.runtime.Symbol) CUP$parser$stack.peek()).value;
		
				RESULT = sen;
			
			
              CUP$parser$result = parser.getSymbolFactory().newSymbol("sentencia",30, ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 59: // sentencia ::= sentencia_if 
            {
              Object RESULT =null;
		int senleft = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).left;
		int senright = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).right;
		Object sen = (Object)((java_cup.runtime.Symbol) CUP$parser$stack.peek()).value;
		
		RESULT = sen;
	
	
              CUP$parser$result = parser.getSymbolFactory().newSymbol("sentencia",30, ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 58: // sentencias ::= sentencia sentencias 
            {
              Object RESULT =null;
		int sen1left = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)).left;
		int sen1right = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)).right;
		Object sen1 = (Object)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-1)).value;
		int sen2left = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).left;
		int sen2right = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).right;
		Object sen2 = (Object)((java_cup.runtime.Symbol) CUP$parser$stack.peek()).value;
		
				Bloque_sentencias bloque_sen = new Bloque_sentencias();
				bloque_sen.addSentencia((Sentencia)sen1);
				bloque_sen.addSentencia((Sentencia)sen2);
				RESULT = bloque_sen;

				
				
				
              CUP$parser$result = parser.getSymbolFactory().newSymbol("sentencias",29, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 57: // sentencias ::= sentencia 
            {
              Object RESULT =null;
		int senleft = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).left;
		int senright = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).right;
		Object sen = (Object)((java_cup.runtime.Symbol) CUP$parser$stack.peek()).value;
		
				//RESULT = sen;
				
              CUP$parser$result = parser.getSymbolFactory().newSymbol("sentencias",29, ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 56: // sentencias ::= bloque_sentencias sentencias 
            {
              Object RESULT =null;
		int bloqueleft = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)).left;
		int bloqueright = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)).right;
		Object bloque = (Object)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-1)).value;
		int senleft = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).left;
		int senright = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).right;
		Object sen = (Object)((java_cup.runtime.Symbol) CUP$parser$stack.peek()).value;
		
				Bloque_sentencias bloque_sen;
				if (bloque ==null)
					bloque_sen = new Bloque_sentencias();
				else
					bloque_sen = (Bloque_sentencias) bloque;
				
				bloque_sen.addSentencia((Sentencia)sen);
				
				
              CUP$parser$result = parser.getSymbolFactory().newSymbol("sentencias",29, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 55: // sentencias ::= bloque_sentencias 
            {
              Object RESULT =null;
		int bloqueleft = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).left;
		int bloqueright = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).right;
		Object bloque = (Object)((java_cup.runtime.Symbol) CUP$parser$stack.peek()).value;
		
			RESULT = bloque;
	
              CUP$parser$result = parser.getSymbolFactory().newSymbol("sentencias",29, ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 54: // declar_variables ::= sentencias 
            {
              Object RESULT =null;

              CUP$parser$result = parser.getSymbolFactory().newSymbol("declar_variables",9, ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 53: // declar_variables ::= declar_variable 
            {
              Object RESULT =null;

              CUP$parser$result = parser.getSymbolFactory().newSymbol("declar_variables",9, ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 52: // declar_variables ::= declar_variable declar_variables 
            {
              Object RESULT =null;

              CUP$parser$result = parser.getSymbolFactory().newSymbol("declar_variables",9, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 51: // declar_tipos ::= declar_variables 
            {
              Object RESULT =null;

              CUP$parser$result = parser.getSymbolFactory().newSymbol("declar_tipos",7, ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 50: // declar_tipos ::= declar_tipo 
            {
              Object RESULT =null;

              CUP$parser$result = parser.getSymbolFactory().newSymbol("declar_tipos",7, ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 49: // declar_tipos ::= declar_tipo declar_tipos 
            {
              Object RESULT =null;

              CUP$parser$result = parser.getSymbolFactory().newSymbol("declar_tipos",7, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 48: // cuerpo_sentencias ::= declar_tipos 
            {
              Object RESULT =null;
		int declarleft = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).left;
		int declarright = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).right;
		Object declar = (Object)((java_cup.runtime.Symbol) CUP$parser$stack.peek()).value;
		
		RESULT = declar;
			
              CUP$parser$result = parser.getSymbolFactory().newSymbol("cuerpo_sentencias",28, ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 47: // bloque_sentencias ::= LLAVEIZQ NT$10 cuerpo_sentencias LLAVEDER 
            {
              Object RESULT =null;
              // propagate RESULT from NT$10
                RESULT = (Object) ((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-2)).value;
		
		scopeManager.closeScope();
		ScopeIF ambito = scopeManager.getCurrentScope();
		System.out.println("Tras cerrar bloque NO vacio"+ ambito);
		
              CUP$parser$result = parser.getSymbolFactory().newSymbol("bloque_sentencias",27, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-3)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 46: // NT$10 ::= 
            {
              Object RESULT =null;

	ScopeIF ambito = scopeManager.openScope();
	System.out.println("Tras abrir bloque NO vacio"+ ambito);
	
              CUP$parser$result = parser.getSymbolFactory().newSymbol("NT$10",50, ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 45: // bloque_sentencias ::= LLAVEIZQ NT$9 LLAVEDER 
            {
              Object RESULT =null;
              // propagate RESULT from NT$9
                RESULT = (Object) ((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-1)).value;

              CUP$parser$result = parser.getSymbolFactory().newSymbol("bloque_sentencias",27, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 44: // NT$9 ::= 
            {
              Object RESULT =null;

	ScopeIF ambito = scopeManager.openScope();
	System.out.println("Tras abrir bloque vacio"+ ambito);
	scopeManager.closeScope();ambito = scopeManager.getCurrentScope();
	System.out.println("Tras cerrar bloque vacio"+ ambito);
	
              CUP$parser$result = parser.getSymbolFactory().newSymbol("NT$9",49, ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 43: // tipo_parametros ::= IDENTIFICADOR 
            {
              Object RESULT =null;
		int idleft = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).left;
		int idright = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).right;
		Token id = (Token)((java_cup.runtime.Symbol) CUP$parser$stack.peek()).value;
		 
	
	semanticErrorManager.semanticFatalError("Error. No se pueden pasar tipos estructurados como parametros en la linea  " + id.getLine());

	
	
              CUP$parser$result = parser.getSymbolFactory().newSymbol("tipo_parametros",16, ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 42: // tipo_parametros ::= ENTERO 
            {
              Object RESULT =null;
		
			ScopeIF sc = scopeManager.getCurrentScope();
			TypeIF tipo = scopeManager.searchType("Entero");

			RESULT = tipo;
	
			
              CUP$parser$result = parser.getSymbolFactory().newSymbol("tipo_parametros",16, ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 41: // lista_declar_parametros ::= lista_declar_parametros COMA tipo_parametros REFERENCIA IDENTIFICADOR 
            {
              Object RESULT =null;
		int listaleft = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-4)).left;
		int listaright = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-4)).right;
		Object lista = (Object)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-4)).value;
		int tipoleft = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)).left;
		int tiporight = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)).right;
		Object tipo = (Object)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-2)).value;
		
								ArrayList<TypeIF> listaTipos;
								
								if (lista == null)
									listaTipos = new ArrayList<TypeIF>();
								else
										listaTipos = (ArrayList<TypeIF>) lista;
								listaTipos.add((TypeIF)tipo);
								
								RESULT = listaTipos;
					 			
					 			
              CUP$parser$result = parser.getSymbolFactory().newSymbol("lista_declar_parametros",18, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-4)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 40: // lista_declar_parametros ::= tipo_parametros REFERENCIA IDENTIFICADOR 
            {
              Object RESULT =null;
		int tipoleft = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)).left;
		int tiporight = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)).right;
		Object tipo = (Object)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-2)).value;
		
								
								ArrayList<TypeIF> listaTipos = new ArrayList<TypeIF>();
								listaTipos.add((TypeIF)tipo);
								RESULT = listaTipos;
								
              CUP$parser$result = parser.getSymbolFactory().newSymbol("lista_declar_parametros",18, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 39: // declar_parametros ::= PARIZQ lista_declar_parametros NT$8 PARDER 
            {
              Object RESULT =null;
              // propagate RESULT from NT$8
                RESULT = (Object) ((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-1)).value;
		int listaTiposleft = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)).left;
		int listaTiposright = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)).right;
		Object listaTipos = (Object)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-2)).value;

              CUP$parser$result = parser.getSymbolFactory().newSymbol("declar_parametros",17, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-3)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 38: // NT$8 ::= 
            {
              Object RESULT =null;
		int listaTiposleft = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).left;
		int listaTiposright = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).right;
		Object listaTipos = (Object)((java_cup.runtime.Symbol) CUP$parser$stack.peek()).value;

						  System.out.println(((ArrayList<TypeIF>)listaTipos).size());
						  
						  
              CUP$parser$result = parser.getSymbolFactory().newSymbol("NT$8",48, ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 37: // declar_parametros ::= PARIZQ PARDER 
            {
              Object RESULT =null;

              CUP$parser$result = parser.getSymbolFactory().newSymbol("declar_parametros",17, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 36: // declar_main ::= VOID MAIN PARIZQ PARDER bloque_sentencias 
            {
              Object RESULT =null;

              CUP$parser$result = parser.getSymbolFactory().newSymbol("declar_main",5, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-4)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 35: // declar_funcion ::= VOID IDENTIFICADOR declar_parametros bloque_sentencias 
            {
              Object RESULT =null;

              CUP$parser$result = parser.getSymbolFactory().newSymbol("declar_funcion",15, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-3)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 34: // declar_funcion ::= ENTERO IDENTIFICADOR NT$7 declar_parametros bloque_sentencias 
            {
              Object RESULT =null;
              // propagate RESULT from NT$7
                RESULT = (Object) ((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-2)).value;
		int idleft = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-3)).left;
		int idright = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-3)).right;
		Token id = (Token)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-3)).value;
		int parametrosleft = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)).left;
		int parametrosright = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)).right;
		Object parametros = (Object)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-1)).value;
		int bloqueleft = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).left;
		int bloqueright = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).right;
		Object bloque = (Object)((java_cup.runtime.Symbol) CUP$parser$stack.peek()).value;
		
						//Bloque_sentencias bq = (Bloque_sentencias)bloque;
						ScopeIF sc = scopeManager.getCurrentScope();
						//bq.introducirTabla(sc);
						
						System.out.println("Estoy en el scope ..." + sc);
						SymbolTableIF ts = sc.getSymbolTable();
					if (scopeManager.containsSymbol(id.getLexema())) {
						semanticErrorManager.semanticFatalError("La funcion " + id.getLexema() + " ya ha sido declarada en la linea " + id.getLine());

					}
	
					scopeManager.closeScope();
					
              CUP$parser$result = parser.getSymbolFactory().newSymbol("declar_funcion",15, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-4)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 33: // NT$7 ::= 
            {
              Object RESULT =null;
		int idleft = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).left;
		int idright = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).right;
		Token id = (Token)((java_cup.runtime.Symbol) CUP$parser$stack.peek()).value;

					
					ScopeIF sc = scopeManager.openScope("Funcion");
					System.out.println("Estoy en el scope de la funcion..." + sc);

	
					
              CUP$parser$result = parser.getSymbolFactory().newSymbol("NT$7",47, ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 32: // lista_variables_matriz ::= lista_variables_matriz COMA IDENTIFICADOR 
            {
              Object RESULT =null;
		int matricesleft = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)).left;
		int matricesright = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)).right;
		Object matrices = (Object)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-2)).value;
		int idleft = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).left;
		int idright = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).right;
		Token id = (Token)((java_cup.runtime.Symbol) CUP$parser$stack.peek()).value;
		
	
	Lista_variables_matriz listaMat = (Lista_variables_matriz) matrices;
	ScopeIF sc = scopeManager.getCurrentScope();
	SymbolTableIF ts = sc.getSymbolTable();
	TypeTableIF tt = sc.getTypeTable();

	
	if (ts.containsSymbol(id.getLexema())){
		semanticErrorManager.semanticFatalError("Error. La matriz " + id.getLexema() + " ya ha sido declarada en la linea " + id.getLine());
	}

	else {
		
		if (tt.containsType(listaMat.getTypeName())) {
			TypeArray tipo = (TypeArray)tt.getType(listaMat.getTypeName());
			listaMat.addMatriz(id.getLexema());
			SymbolMatrix mat = new SymbolMatrix(sc,id.getLexema(),tipo,tipo.getR1(),tipo.getR2());
			ts.addSymbol(mat);
			System.out.println(ts);
				
			}
		
		}



              CUP$parser$result = parser.getSymbolFactory().newSymbol("lista_variables_matriz",14, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 31: // lista_variables_matriz ::= IDENTIFICADOR IDENTIFICADOR 
            {
              Object RESULT =null;
		int id1left = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)).left;
		int id1right = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)).right;
		Token id1 = (Token)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-1)).value;
		int id2left = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).left;
		int id2right = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).right;
		Token id2 = (Token)((java_cup.runtime.Symbol) CUP$parser$stack.peek()).value;
		
	
	ScopeIF sc = scopeManager.getCurrentScope();
	SymbolTableIF ts = sc.getSymbolTable();
	TypeTableIF tt = sc.getTypeTable();

	
	if (ts.containsSymbol(id2.getLexema())){
		semanticErrorManager.semanticFatalError("Error. La matriz " + id2.getLexema() + " ya ha sido declarada en la linea " + id2.getLine());
	}
	else {
		
			if (tt.containsType(id1.getLexema())) {
				TypeArray tipo = (TypeArray)tt.getType(id1.getLexema());
				Lista_variables_matriz listaMat = new Lista_variables_matriz(tipo.getR1(), tipo.getR2(), id1.getLexema());
				listaMat.addMatriz(id2.getLexema());
				SymbolMatrix mat = new SymbolMatrix(sc,id2.getLexema(),tipo,tipo.getR1(),tipo.getR2());
				ts.addSymbol(mat);
				RESULT = listaMat;
				
			}
		
		}



              CUP$parser$result = parser.getSymbolFactory().newSymbol("lista_variables_matriz",14, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 30: // lista_variables_enteras ::= lista_variables_enteras COMA IDENTIFICADOR ASIGNACION IDENTIFICADOR 
            {
              Object RESULT =null;
		int varleft = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-4)).left;
		int varright = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-4)).right;
		Object var = (Object)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-4)).value;
		int id1left = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)).left;
		int id1right = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)).right;
		Token id1 = (Token)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-2)).value;
		int id2left = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).left;
		int id2right = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).right;
		Token id2 = (Token)((java_cup.runtime.Symbol) CUP$parser$stack.peek()).value;
		
							
							
							Lista_variables_Enteras listaVar = (Lista_variables_Enteras)var;
							ScopeIF sc = scopeManager.getCurrentScope();
							SymbolTableIF ts = sc.getSymbolTable();
							


							if (ts.containsSymbol(id1.getLexema())){
								semanticErrorManager.semanticFatalError("Error. La variable:" + id1.getLexema() + " ya ha sido declarada en la linea " + id1.getLine());
							}
							else {
								//Comprobamos que exista el símbolo correspondiente
								if (ts.containsSymbol(id2.getLexema())) {
									SymbolIF simbolo = (ts.getSymbol(id2.getLexema()));
									SymbolVariable sVariable;
									listaVar.addVariable(id1.getLexema(),scopeManager.searchType("Entero"));
									//Comprobamos que el símbolo es del tipo adecuado
									if(simbolo.getType() instanceof TypeSimple){	
										//Hacemos casting según sea el tipo variable o constante. A continuación creamos el nuevo símbolo y lo introducimos a la tabla
										if (simbolo instanceof SymbolVariable) {
											
											 
											 sVariable = new SymbolVariable(sc,id1.getLexema(), scopeManager.searchType("Entero"),((SymbolVariable)simbolo).getValor() );

										}
											else {
												sVariable = new SymbolVariable(sc,id1.getLexema(), scopeManager.searchType("Entero"),((SymbolConstant)simbolo).getValor() );

											}
										
										listaVar.setValor(sVariable.getValor());
									
										ts.addSymbol(sVariable);
										ts= listaVar.actualizaValores(ts);

									    

										RESULT = listaVar;
										
										}
								
									else
										semanticErrorManager.semanticFatalError("Error. Asignación incorrecta a la variable:" + id1.getLexema() + "en la línea" + id1.getLine() );

									
							}
								else
									semanticErrorManager.semanticFatalError("Error. No existe el identificador:" + id2.getLexema() + "en la línea" + id1.getLine() );

								
							
							}
								
								
								
								
							
              CUP$parser$result = parser.getSymbolFactory().newSymbol("lista_variables_enteras",13, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-4)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 29: // lista_variables_enteras ::= lista_variables_enteras COMA IDENTIFICADOR ASIGNACION NUMERO 
            {
              Object RESULT =null;
		int varleft = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-4)).left;
		int varright = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-4)).right;
		Object var = (Object)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-4)).value;
		int idleft = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)).left;
		int idright = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)).right;
		Token id = (Token)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-2)).value;
		int valorleft = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).left;
		int valorright = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).right;
		Token valor = (Token)((java_cup.runtime.Symbol) CUP$parser$stack.peek()).value;
		
								
								//Añadimos el valor a la variable que sube y introducimos la nueva
									
									Lista_variables_Enteras listaVar = (Lista_variables_Enteras)var;
									listaVar.setValor(Integer.parseInt(valor.getLexema()));
									ScopeIF sc = scopeManager.getCurrentScope();
									SymbolTableIF ts = sc.getSymbolTable();
								    ts= listaVar.actualizaValores(ts);

							

									if (ts.containsSymbol(id.getLexema())){
										semanticErrorManager.semanticFatalError("Error. La variable:" + id.getLexema() + " ya ha sido declarada en la linea " + id.getLine());
									}
									else {
										if(TypeSimple.rangoCorrecto(Integer.parseInt(valor.getLexema()))){										
											listaVar.addVariable(id.getLexema(),scopeManager.searchType("Entero"));
											SymbolVariable sVariable = new SymbolVariable(sc,id.getLexema(), scopeManager.searchType("Entero"), Integer.parseInt(valor.getLexema()));

											ts.addSymbol(sVariable);
											RESULT = listaVar;
											}
										
										else
											semanticErrorManager.semanticFatalError("Error. El numero " + valor.getLexema() + " excede el rango permitido para las variables en la linea " + valor.getLine());

											
									};
								
								
								
              CUP$parser$result = parser.getSymbolFactory().newSymbol("lista_variables_enteras",13, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-4)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 28: // lista_variables_enteras ::= lista_variables_enteras COMA IDENTIFICADOR 
            {
              Object RESULT =null;
		int varleft = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)).left;
		int varright = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)).right;
		Object var = (Object)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-2)).value;
		int idleft = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).left;
		int idright = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).right;
		Token id = (Token)((java_cup.runtime.Symbol) CUP$parser$stack.peek()).value;
		
								 //Análogo a la versión anterior
									ScopeIF sc = scopeManager.getCurrentScope();
									SymbolTableIF ts = sc.getSymbolTable();


									if (ts.containsSymbol(id.getLexema())){
										semanticErrorManager.semanticFatalError("Error. La variable:" + id.getLexema() + " ya ha sido declarada en la linea " + id.getLine());
									}
									else {
										Lista_variables_Enteras listaVar = (Lista_variables_Enteras)var;
										listaVar.addVariable(id.getLexema(),scopeManager.searchType("Entero"));
										SymbolVariable sVariable = new SymbolVariable(sc,id.getLexema(), scopeManager.searchType("Entero"));

										ts.addSymbol(sVariable);
										RESULT = listaVar;
									}
		
              CUP$parser$result = parser.getSymbolFactory().newSymbol("lista_variables_enteras",13, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 27: // lista_variables_enteras ::= ENTERO IDENTIFICADOR ASIGNACION IDENTIFICADOR 
            {
              Object RESULT =null;
		int id1left = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)).left;
		int id1right = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)).right;
		Token id1 = (Token)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-2)).value;
		int id2left = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).left;
		int id2right = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).right;
		Token id2 = (Token)((java_cup.runtime.Symbol) CUP$parser$stack.peek()).value;
		
									ScopeIF sc = scopeManager.getCurrentScope();
									SymbolTableIF ts = sc.getSymbolTable();

									if (ts.containsSymbol(id1.getLexema())){
										semanticErrorManager.semanticFatalError("Error. La variable:" + id1.getLexema() + " ya ha sido declarada en la linea " + id1.getLine());
									}
									else {
										//Comprobamos que exista el símbolo correspondiente
										if (ts.containsSymbol(id2.getLexema())) {
											SymbolIF simbolo = (ts.getSymbol(id2.getLexema()));
											SymbolVariable sVariable;
											Lista_variables_Enteras listaVar = new Lista_variables_Enteras();											//Comprobamos que el símbolo es del tipo adecuado
											if(simbolo.getType() instanceof TypeSimple){	
												//Hacemos casting según sea el tipo variable o constante. A continuación creamos el nuevo símbolo y lo introducimos a la tabla
												
												listaVar.addVariable(id1.getLexema(),scopeManager.searchType("Entero"));
												if (simbolo instanceof SymbolVariable) {
													 sVariable = new SymbolVariable(sc,id1.getLexema(), scopeManager.searchType("Entero"),((SymbolVariable)simbolo).getValor());

												}
													else {
													 sVariable = new SymbolVariable(sc,id1.getLexema(), scopeManager.searchType("Entero"),((SymbolConstant)simbolo).getValor() );

													}
												
												listaVar.setValor(sVariable.getValor());
												ts.addSymbol(sVariable);
												RESULT = listaVar;
												
												}
										
											else
												semanticErrorManager.semanticFatalError("Error. Asignación incorrecta a la variable:" + id1.getLexema() + "en la línea" + id1.getLine() );

											
									}
										else
											semanticErrorManager.semanticFatalError("Error. No existe el identificador:" + id2.getLexema() + "en la línea" + id1.getLine() );

										
									
									}
		
              CUP$parser$result = parser.getSymbolFactory().newSymbol("lista_variables_enteras",13, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-3)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 26: // lista_variables_enteras ::= ENTERO IDENTIFICADOR ASIGNACION NUMERO 
            {
              Object RESULT =null;
		int idleft = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)).left;
		int idright = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)).right;
		Token id = (Token)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-2)).value;
		int valorleft = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).left;
		int valorright = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).right;
		Token valor = (Token)((java_cup.runtime.Symbol) CUP$parser$stack.peek()).value;
		
									ScopeIF sc = scopeManager.getCurrentScope();
									SymbolTableIF ts = sc.getSymbolTable();

									if (ts.containsSymbol(id.getLexema())){
										semanticErrorManager.semanticFatalError("Error. La variable:" + id.getLexema() + " ya ha sido declarada en la linea " + id.getLine());
									}
									else {
										if(TypeSimple.rangoCorrecto(Integer.parseInt(valor.getLexema()))){										
											Lista_variables_Enteras listaVar = new Lista_variables_Enteras();
											listaVar.addVariable(id.getLexema(),scopeManager.searchType("Entero"));
											listaVar.setValor(Integer.parseInt(valor.getLexema()));
											SymbolVariable sVariable = new SymbolVariable(sc,id.getLexema(),  scopeManager.searchType("Entero"), Integer.parseInt(valor.getLexema()));
											ts.addSymbol(sVariable);
										
											RESULT = listaVar;}
										
										else
											semanticErrorManager.semanticFatalError("Error. El numero " + valor.getLexema() + " excede el rango permitido para las variables en la linea " + valor.getLine());

											
									}
		
              CUP$parser$result = parser.getSymbolFactory().newSymbol("lista_variables_enteras",13, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-3)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 25: // lista_variables_enteras ::= ENTERO IDENTIFICADOR 
            {
              Object RESULT =null;
		int idleft = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).left;
		int idright = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).right;
		Token id = (Token)((java_cup.runtime.Symbol) CUP$parser$stack.peek()).value;
		
									ScopeIF sc = scopeManager.getCurrentScope();
									SymbolTableIF ts = sc.getSymbolTable();

									if (ts.containsSymbol(id.getLexema())){
										semanticErrorManager.semanticFatalError("Error. La variable:" + id.getLexema() + " ya ha sido declarada en la linea " + id.getLine());
									}
									else {
										Lista_variables_Enteras listaVar = new Lista_variables_Enteras();
										listaVar.addVariable(id.getLexema(),scopeManager.searchType("Entero"));
										SymbolVariable sVariable = new SymbolVariable(sc,id.getLexema(), scopeManager.searchType("Entero"));
										ts.addSymbol(sVariable);
										RESULT = listaVar;
									}
		
              CUP$parser$result = parser.getSymbolFactory().newSymbol("lista_variables_enteras",13, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 24: // declar_variable ::= lista_variables_matriz PUNTOYCOMA 
            {
              Object RESULT =null;

              CUP$parser$result = parser.getSymbolFactory().newSymbol("declar_variable",10, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 23: // declar_variable ::= lista_variables_enteras PUNTOYCOMA 
            {
              Object RESULT =null;
		
	
	ScopeIF sc = scopeManager.getCurrentScope();
SymbolTableIF ts = sc.getSymbolTable();

	
              CUP$parser$result = parser.getSymbolFactory().newSymbol("declar_variable",10, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 22: // rango_matriz ::= CORIZQ expresion CORDER 
            {
              Object RESULT =null;
		int exleft = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)).left;
		int exright = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)).right;
		Object ex = (Object)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-1)).value;
		int cleft = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).left;
		int cright = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).right;
		Token c = (Token)((java_cup.runtime.Symbol) CUP$parser$stack.peek()).value;
		
	
		RESULT =  ((Expresion)ex).getValor();

	
              CUP$parser$result = parser.getSymbolFactory().newSymbol("rango_matriz",12, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 21: // rango_matriz_declar ::= CORIZQ IDENTIFICADOR NT$6 CORDER 
            {
              Object RESULT =null;
              // propagate RESULT from NT$6
                RESULT = (Object) ((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-1)).value;
		int rleft = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)).left;
		int rright = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)).right;
		Token r = (Token)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-2)).value;

              CUP$parser$result = parser.getSymbolFactory().newSymbol("rango_matriz_declar",11, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-3)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 20: // NT$6 ::= 
            {
              Object RESULT =null;
		int rleft = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).left;
		int rright = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).right;
		Token r = (Token)((java_cup.runtime.Symbol) CUP$parser$stack.peek()).value;

						
					ScopeIF sc = scopeManager.getCurrentScope();
					SymbolTableIF ts = sc.getSymbolTable();
					
					//Comprobamos que en la tabla de símbolos aparece el simbolo correspondiente. En caso afirmativo recuperamos su valor y comprobamos que no excede el rango.
					if (ts.containsSymbol(r.getLexema())) {
						SymbolIF c = ts.getSymbol(r.getLexema());
						if (TypeSimple.rangoPositivo(((SymbolConstant)c).getValor())) {
							RESULT = ((SymbolConstant)c).getValor();
						}
						else
							semanticErrorManager.semanticFatalError("Error. El numero " + r.getLexema() + " excede el rango permitido en  la matriz en la linea " + r.getLine());
					}
					else 	semanticErrorManager.semanticFatalError("Error. No existe el identificador " + r.getLexema() + "  en la linea " + r.getLine());
						
					
              CUP$parser$result = parser.getSymbolFactory().newSymbol("NT$6",46, ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 19: // rango_matriz_declar ::= CORIZQ NUMERO NT$5 CORDER 
            {
              Object RESULT =null;
              // propagate RESULT from NT$5
                RESULT = (Object) ((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-1)).value;
		int rleft = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)).left;
		int rright = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)).right;
		Token r = (Token)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-2)).value;

              CUP$parser$result = parser.getSymbolFactory().newSymbol("rango_matriz_declar",11, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-3)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 18: // NT$5 ::= 
            {
              Object RESULT =null;
		int rleft = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).left;
		int rright = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).right;
		Token r = (Token)((java_cup.runtime.Symbol) CUP$parser$stack.peek()).value;

						if (TypeSimple.rangoPositivo(Integer.parseInt(r.getLexema()))){
							RESULT =Integer.parseInt(r.getLexema());
						}
						else
							semanticErrorManager.semanticFatalError("Error. El numero " + r.getLexema() + " excede el rango permitido en  la matriz en la linea " + r.getLine());
							
						
					
              CUP$parser$result = parser.getSymbolFactory().newSymbol("NT$5",45, ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 17: // declar_tipo ::= ENTERO IDENTIFICADOR rango_matriz_declar rango_matriz_declar NT$4 PUNTOYCOMA 
            {
              Object RESULT =null;
              // propagate RESULT from NT$4
                RESULT = (Object) ((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-1)).value;
		int idleft = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-4)).left;
		int idright = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-4)).right;
		Token id = (Token)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-4)).value;
		int r1left = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-3)).left;
		int r1right = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-3)).right;
		Object r1 = (Object)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-3)).value;
		int r2left = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)).left;
		int r2right = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)).right;
		Object r2 = (Object)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-2)).value;

              CUP$parser$result = parser.getSymbolFactory().newSymbol("declar_tipo",8, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-5)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 16: // NT$4 ::= 
            {
              Object RESULT =null;
		int idleft = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)).left;
		int idright = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)).right;
		Token id = (Token)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-2)).value;
		int r1left = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)).left;
		int r1right = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)).right;
		Object r1 = (Object)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-1)).value;
		int r2left = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).left;
		int r2right = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).right;
		Object r2 = (Object)((java_cup.runtime.Symbol) CUP$parser$stack.peek()).value;

					ScopeIF sc = scopeManager.getCurrentScope();
					TypeTableIF tt = sc.getTypeTable();
					if (tt.containsType(id.getLexema()))
						semanticErrorManager.semanticFatalError("Error. El tipo:" + id.getLexema() + " ya ha sido declarado con anterioridad en la linea " + id.getLine());
					else {
						TypeArray matriz = new TypeArray(sc,id.getLexema(), (int)r1,(int)r2);
						tt.addType(id.getLexema(),matriz);
						Declar_tipo tipo = new Declar_tipo(id.getLexema(), (int)r1, (int)r2);
						RESULT =  tipo;
						
					

					}
	
	
	
              CUP$parser$result = parser.getSymbolFactory().newSymbol("NT$4",44, ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 15: // declar_const ::= DEFINE IDENTIFICADOR NUMERO NT$3 PUNTOYCOMA 
            {
              Object RESULT =null;
              // propagate RESULT from NT$3
                RESULT = (Object) ((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-1)).value;
		int idleft = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-3)).left;
		int idright = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-3)).right;
		Token id = (Token)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-3)).value;
		int valorleft = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)).left;
		int valorright = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)).right;
		Token valor = (Token)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-2)).value;

              CUP$parser$result = parser.getSymbolFactory().newSymbol("declar_const",6, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-4)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 14: // NT$3 ::= 
            {
              Object RESULT =null;
		int idleft = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)).left;
		int idright = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)).right;
		Token id = (Token)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-1)).value;
		int valorleft = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).left;
		int valorright = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).right;
		Token valor = (Token)((java_cup.runtime.Symbol) CUP$parser$stack.peek()).value;

				ScopeIF sc = scopeManager.getCurrentScope();
				SymbolTableIF ts = sc.getSymbolTable();
				
				if (ts.containsSymbol(id.getLexema())){
					semanticErrorManager.semanticFatalError("La constante:" + id.getLexema() + " ya ha sido declarada en la linea " + id.getLine());
				}
				else {
					if (TypeSimple.rangoCorrecto(Integer.parseInt(valor.getLexema()))) {
						SymbolConstant sConstant = new SymbolConstant(sc,id.getLexema(), scopeManager.searchType("Entero"), Integer.parseInt(valor.getLexema()));
						Declar_const c = new Declar_const(Integer.parseInt(valor.getLexema()),"Constante");
						ts.addSymbol(sConstant);
						RESULT = c;
					}
					else
						semanticErrorManager.semanticFatalError("Error. La constante:" + id.getLexema() + " tiene un valor fuera de rango en la linea" + id.getLine());
					
					
				}
				
              CUP$parser$result = parser.getSymbolFactory().newSymbol("NT$3",43, ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 13: // declar_funciones_glo ::= declar_main 
            {
              Object RESULT =null;

              CUP$parser$result = parser.getSymbolFactory().newSymbol("declar_funciones_glo",4, ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 12: // declar_funciones_glo ::= declar_funcion declar_funciones_glo 
            {
              Object RESULT =null;

              CUP$parser$result = parser.getSymbolFactory().newSymbol("declar_funciones_glo",4, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 11: // declar_variables_glo ::= declar_funciones_glo 
            {
              Object RESULT =null;

              CUP$parser$result = parser.getSymbolFactory().newSymbol("declar_variables_glo",3, ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 10: // declar_variables_glo ::= declar_variable declar_variables_glo 
            {
              Object RESULT =null;

              CUP$parser$result = parser.getSymbolFactory().newSymbol("declar_variables_glo",3, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 9: // declar_tipos_glo ::= declar_variables_glo 
            {
              Object RESULT =null;

              CUP$parser$result = parser.getSymbolFactory().newSymbol("declar_tipos_glo",2, ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 8: // declar_tipos_glo ::= declar_tipo declar_tipos_glo 
            {
              Object RESULT =null;

              CUP$parser$result = parser.getSymbolFactory().newSymbol("declar_tipos_glo",2, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 7: // declar_consts ::= declar_tipos_glo 
            {
              Object RESULT =null;

              CUP$parser$result = parser.getSymbolFactory().newSymbol("declar_consts",1, ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 6: // declar_consts ::= declar_const NT$2 declar_consts 
            {
              Object RESULT =null;
              // propagate RESULT from NT$2
                RESULT = (Object) ((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-1)).value;
		int cleft = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)).left;
		int cright = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)).right;
		Object c = (Object)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-2)).value;

              CUP$parser$result = parser.getSymbolFactory().newSymbol("declar_consts",1, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 5: // NT$2 ::= 
            {
              Object RESULT =null;
		int cleft = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).left;
		int cright = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).right;
		Object c = (Object)((java_cup.runtime.Symbol) CUP$parser$stack.peek()).value;

	
			RESULT = c;
			
              CUP$parser$result = parser.getSymbolFactory().newSymbol("NT$2",42, ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 4: // axiom ::= NT$1 declar_consts 
            {
              Axiom RESULT =null;
              // propagate RESULT from NT$1
                RESULT = (Axiom) ((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-1)).value;

              CUP$parser$result = parser.getSymbolFactory().newSymbol("axiom",35, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 3: // NT$1 ::= 
            {
              Axiom RESULT =null;

	
			//Abrimos el ámbito global, creamos los tipos y los añadimos a la tabla de símbolos
			ScopeIF ambito = scopeManager.openScope("Global");
			
			System.out.println("Tras abrir ambito principal "+ ambito);
			TypeTableIF tt = ambito.getTypeTable();
			TypeSimple entero = new TypeSimple(ambito,"Entero");
			tt.addType("Entero",entero);
			
			
		
			
			
              CUP$parser$result = parser.getSymbolFactory().newSymbol("NT$1",41, ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 2: // program ::= NT$0 axiom 
            {
              Object RESULT =null;
              // propagate RESULT from NT$0
                RESULT = (Object) ((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-1)).value;
		int axleft = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).left;
		int axright = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).right;
		Axiom ax = (Axiom)((java_cup.runtime.Symbol) CUP$parser$stack.peek()).value;
		 
  		// No modificar esta estructura, aunque se pueden añadir más acciones semánticas
  		
  		//List intermediateCode = ax.getIntermediateCode ();
  		//finalCodeFactory.create (intermediateCode);
  		// En caso de no comentarse las sentencias anteriores puede generar una excepcion
  		// en las llamadas a cupTest si el compilador no está completo. Esto es debido a que 
  		// aún no se tendrá implementada la generación de código intermedio ni final.
  		// Para la entrega final deberán descomentarse y usarse.
  		
  		syntaxErrorManager.syntaxInfo ("Parsing process ended.");
  
              CUP$parser$result = parser.getSymbolFactory().newSymbol("program",0, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 1: // NT$0 ::= 
            {
              Object RESULT =null;
 syntaxErrorManager.syntaxInfo ("Starting parsing..."); 
	
	
  
              CUP$parser$result = parser.getSymbolFactory().newSymbol("NT$0",40, ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 0: // $START ::= program EOF 
            {
              Object RESULT =null;
		int start_valleft = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)).left;
		int start_valright = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)).right;
		Object start_val = (Object)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-1)).value;
		RESULT = start_val;
              CUP$parser$result = parser.getSymbolFactory().newSymbol("$START",0, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          /* ACCEPT */
          CUP$parser$parser.done_parsing();
          return CUP$parser$result;

          /* . . . . . .*/
          default:
            throw new Exception(
               "Invalid action number found in internal parse table");

        }
    }
}

