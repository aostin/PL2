
//----------------------------------------------------
// The following code was generated by CUP v0.11a beta 20060608
// Mon Apr 23 22:16:27 CEST 2018
//----------------------------------------------------

package compiler.syntax;

import java_cup.runtime.Symbol;
import java.util.*;
import es.uned.lsi.compiler.lexical.*;
import es.uned.lsi.compiler.code.*;
import es.uned.lsi.compiler.intermediate.*;
import es.uned.lsi.compiler.semantic.*;
import es.uned.lsi.compiler.semantic.symbol.*;
import es.uned.lsi.compiler.semantic.type.*;
import es.uned.lsi.compiler.syntax.*;
import compiler.CompilerContext;
import compiler.lexical.*;
import compiler.syntax.nonTerminal.*;
import compiler.semantic.*;
import compiler.semantic.symbol.*;
import compiler.semantic.type.*;
import compiler.intermediate.*;
import compiler.code.*;

/** CUP v0.11a beta 20060608 generated parser.
  * @version Mon Apr 23 22:16:27 CEST 2018
  */
public class parser extends java_cup.runtime.lr_parser {

  /** Default constructor. */
  public parser() {super();}

  /** Constructor which sets the default scanner. */
  public parser(java_cup.runtime.Scanner s) {super(s);}

  /** Constructor which sets the default scanner. */
  public parser(java_cup.runtime.Scanner s, java_cup.runtime.SymbolFactory sf) {super(s,sf);}

  /** Production table. */
  protected static final short _production_table[][] = 
    unpackFromStrings(new String[] {
    "\000\141\000\002\002\004\000\002\052\002\000\002\002" +
    "\004\000\002\053\002\000\002\045\004\000\002\054\002" +
    "\000\002\003\005\000\002\003\003\000\002\004\004\000" +
    "\002\004\003\000\002\005\004\000\002\005\003\000\002" +
    "\006\004\000\002\006\003\000\002\055\002\000\002\010" +
    "\007\000\002\056\002\000\002\012\010\000\002\057\002" +
    "\000\002\015\006\000\002\060\002\000\002\015\006\000" +
    "\002\016\005\000\002\014\004\000\002\014\004\000\002" +
    "\017\004\000\002\017\006\000\002\017\006\000\002\017" +
    "\005\000\002\017\007\000\002\017\007\000\002\020\004" +
    "\000\002\020\005\000\002\021\006\000\002\021\006\000" +
    "\002\007\007\000\002\023\004\000\002\023\005\000\002" +
    "\024\005\000\002\024\007\000\002\022\003\000\002\022" +
    "\003\000\002\061\002\000\002\035\005\000\002\062\002" +
    "\000\002\035\006\000\002\036\003\000\002\011\004\000" +
    "\002\011\003\000\002\011\003\000\002\013\004\000\002" +
    "\013\003\000\002\013\003\000\002\037\003\000\002\037" +
    "\004\000\002\037\003\000\002\037\004\000\002\040\003" +
    "\000\002\040\003\000\002\040\003\000\002\040\003\000" +
    "\002\040\004\000\002\040\004\000\002\040\003\000\002" +
    "\026\005\000\002\026\007\000\002\027\003\000\002\027" +
    "\003\000\002\027\005\000\002\027\003\000\002\027\005" +
    "\000\002\027\005\000\002\027\005\000\002\027\005\000" +
    "\002\027\005\000\002\025\003\000\002\025\003\000\002" +
    "\030\004\000\002\031\004\000\002\031\005\000\002\032" +
    "\003\000\002\032\005\000\002\033\003\000\002\033\005" +
    "\000\002\041\007\000\002\041\007\000\002\041\011\000" +
    "\002\041\011\000\002\041\011\000\002\041\011\000\002" +
    "\042\007\000\002\042\007\000\002\043\007\000\002\043" +
    "\006\000\002\044\007\000\002\034\005\000\002\034\004" +
    "" });

  /** Access to production table. */
  public short[][] production_table() {return _production_table;}

  /** Parse-action table. */
  protected static final short[][] _action_table = 
    unpackFromStrings(new String[] {
    "\000\274\000\012\004\000\005\000\010\000\015\000\001" +
    "\002\000\004\002\276\001\002\000\012\004\ufffe\005\ufffe" +
    "\010\ufffe\015\ufffe\001\002\000\012\004\025\005\010\010" +
    "\012\015\014\001\002\000\004\002\uffff\001\002\000\004" +
    "\004\272\001\002\000\012\004\ufffc\005\ufffc\010\ufffc\015" +
    "\ufffc\001\002\000\004\004\267\001\002\000\004\002\ufff8" +
    "\001\002\000\006\004\260\011\261\001\002\000\006\027" +
    "\255\030\256\001\002\000\006\027\247\030\250\001\002" +
    "\000\004\002\ufff4\001\002\000\004\002\ufffa\001\002\000" +
    "\006\010\244\015\014\001\002\000\004\002\ufff6\001\002" +
    "\000\004\002\ufffd\001\002\000\010\004\025\010\031\015" +
    "\014\001\002\000\004\004\030\001\002\000\010\004\025" +
    "\010\012\015\014\001\002\000\004\002\ufff9\001\002\000" +
    "\006\027\uffe2\030\uffe2\001\002\000\004\004\033\001\002" +
    "\000\004\002\ufff7\001\002\000\012\021\035\027\uffe8\030" +
    "\uffe8\035\034\001\002\000\006\004\243\020\242\001\002" +
    "\000\010\004\227\010\232\022\226\001\002\000\004\025" +
    "\040\001\002\000\006\010\uffe0\015\uffe0\001\002\000\024" +
    "\004\uffd5\006\uffd5\010\uffd5\012\uffd5\013\uffd5\014\uffd5\016" +
    "\uffd5\025\uffd5\026\uffd7\001\002\000\022\004\067\006\060" +
    "\010\070\012\063\013\057\014\055\016\052\025\040\001" +
    "\002\000\004\026\043\001\002\000\032\002\uffd6\004\uffd6" +
    "\006\uffd6\007\uffd6\010\uffd6\012\uffd6\013\uffd6\014\uffd6\015" +
    "\uffd6\016\uffd6\025\uffd6\026\uffd6\001\002\000\004\026\uffd0" +
    "\001\002\000\024\004\uffc6\006\uffc6\007\uffc6\012\uffc6\013" +
    "\uffc6\014\uffc6\016\uffc6\025\uffc6\026\uffc6\001\002\000\024" +
    "\004\uffc2\006\uffc2\007\uffc2\012\uffc2\013\uffc2\014\uffc2\016" +
    "\uffc2\025\uffc2\026\uffc2\001\002\000\024\004\067\006\060" +
    "\010\070\012\063\013\057\014\055\016\052\025\040\026" +
    "\uffd1\001\002\000\004\026\uffcd\001\002\000\024\004\uffc5" +
    "\006\uffc5\007\uffc5\012\uffc5\013\uffc5\014\uffc5\016\uffc5\025" +
    "\uffc5\026\uffc5\001\002\000\004\021\220\001\002\000\022" +
    "\004\164\006\060\012\063\013\057\014\055\016\052\025" +
    "\040\026\uffcc\001\002\000\024\004\uffc8\006\uffc8\007\uffc8" +
    "\012\uffc8\013\uffc8\014\uffc8\016\uffc8\025\uffc8\026\uffc8\001" +
    "\002\000\012\004\150\020\131\021\133\030\214\001\002" +
    "\000\004\026\uffd3\001\002\000\004\021\206\001\002\000" +
    "\004\021\173\001\002\000\004\026\172\001\002\000\004" +
    "\030\171\001\002\000\004\021\165\001\002\000\022\004" +
    "\164\006\060\012\063\013\057\014\055\016\052\025\040" +
    "\026\uffca\001\002\000\004\030\162\001\002\000\024\004" +
    "\uffc7\006\uffc7\007\uffc7\012\uffc7\013\uffc7\014\uffc7\016\uffc7" +
    "\025\uffc7\026\uffc7\001\002\000\012\004\030\021\114\023" +
    "\111\035\112\001\002\000\004\004\075\001\002\000\024" +
    "\004\067\006\060\010\073\012\063\013\057\014\055\016" +
    "\052\025\040\026\uffce\001\002\000\004\026\uffcf\001\002" +
    "\000\004\004\074\001\002\000\010\027\uffe8\030\uffe8\035" +
    "\034\001\002\000\012\023\076\027\uffe8\030\uffe8\035\034" +
    "\001\002\000\006\004\104\020\103\001\002\000\004\023" +
    "\076\001\002\000\004\030\ufff1\001\002\000\004\030\102" +
    "\001\002\000\026\004\ufff0\006\ufff0\010\ufff0\012\ufff0\013" +
    "\ufff0\014\ufff0\015\ufff0\016\ufff0\025\ufff0\026\ufff0\001\002" +
    "\000\004\024\uffef\001\002\000\004\024\uffed\001\002\000" +
    "\004\024\106\001\002\000\006\023\uffec\030\uffec\001\002" +
    "\000\004\024\110\001\002\000\006\023\uffee\030\uffee\001" +
    "\002\000\010\004\150\020\131\021\133\001\002\000\010" +
    "\004\134\020\131\021\133\001\002\000\004\023\111\001" +
    "\002\000\006\004\120\022\116\001\002\000\020\022\uffb4" +
    "\024\uffb4\030\uffb4\031\uffb4\032\uffb4\033\uffb4\034\uffb4\001" +
    "\002\000\020\022\uffb3\024\uffb3\030\uffb3\031\uffb3\032\uffb3" +
    "\033\uffb3\034\uffb3\001\002\000\006\022\125\027\124\001" +
    "\002\000\010\022\uffaf\023\111\027\uffaf\001\002\000\006" +
    "\022\uffb1\027\uffb1\001\002\000\004\023\111\001\002\000" +
    "\006\022\uffae\027\uffae\001\002\000\004\004\120\001\002" +
    "\000\020\022\uffb2\024\uffb2\030\uffb2\031\uffb2\032\uffb2\033" +
    "\uffb2\034\uffb2\001\002\000\006\022\uffb0\027\uffb0\001\002" +
    "\000\004\035\130\001\002\000\010\004\134\020\131\021" +
    "\133\001\002\000\020\022\uffbf\024\uffbf\030\uffbf\031\uffbf" +
    "\032\uffbf\033\uffbf\034\uffbf\001\002\000\020\022\uffbc\024" +
    "\uffbc\030\uffbc\031\uffbc\032\uffbc\033\uffbc\034\uffbc\001\002" +
    "\000\010\004\150\020\131\021\133\001\002\000\024\021" +
    "\114\022\uffbe\023\111\024\uffbe\030\uffbe\031\uffbe\032\uffbe" +
    "\033\uffbe\034\uffbe\001\002\000\020\022\uffc0\024\uffc0\030" +
    "\uffc0\031\136\032\141\033\140\034\137\001\002\000\010" +
    "\004\134\020\131\021\133\001\002\000\010\004\134\020" +
    "\131\021\133\001\002\000\010\004\134\020\131\021\133" +
    "\001\002\000\010\004\134\020\131\021\133\001\002\000" +
    "\020\022\uffba\024\uffba\030\uffba\031\136\032\uffba\033\uffba" +
    "\034\uffba\001\002\000\020\022\uffb9\024\uffb9\030\uffb9\031" +
    "\136\032\141\033\uffb9\034\uffb9\001\002\000\020\022\uffb8" +
    "\024\uffb8\030\uffb8\031\136\032\141\033\140\034\uffb8\001" +
    "\002\000\020\022\uffbb\024\uffbb\030\uffbb\031\uffbb\032\uffbb" +
    "\033\uffbb\034\uffbb\001\002\000\004\023\111\001\002\000" +
    "\020\022\uffbd\024\uffbd\030\uffbd\031\uffbd\032\uffbd\033\uffbd" +
    "\034\uffbd\001\002\000\026\021\114\022\uffbe\023\111\024" +
    "\uffbe\030\uffbe\031\uffbe\032\uffbe\033\uffbe\034\uffbe\035\112" +
    "\001\002\000\020\022\uffb6\024\uffb6\030\uffb6\031\136\032" +
    "\141\033\140\034\137\001\002\000\010\022\uffb5\024\uffb5" +
    "\030\uffb5\001\002\000\004\022\154\001\002\000\020\022" +
    "\uffb7\024\uffb7\030\uffb7\031\uffb7\032\uffb7\033\uffb7\034\uffb7" +
    "\001\002\000\004\023\111\001\002\000\022\022\uffbd\024" +
    "\uffbd\030\uffbd\031\uffbd\032\uffbd\033\uffbd\034\uffbd\035\130" +
    "\001\002\000\020\022\uffc1\024\uffc1\030\uffc1\031\136\032" +
    "\141\033\140\034\137\001\002\000\004\024\161\001\002" +
    "\000\026\022\uffeb\023\uffeb\024\uffeb\027\uffeb\030\uffeb\031" +
    "\uffeb\032\uffeb\033\uffeb\034\uffeb\035\uffeb\001\002\000\024" +
    "\004\uffc3\006\uffc3\007\uffc3\012\uffc3\013\uffc3\014\uffc3\016" +
    "\uffc3\025\uffc3\026\uffc3\001\002\000\004\026\uffc9\001\002" +
    "\000\010\021\114\023\111\035\112\001\002\000\004\017" +
    "\166\001\002\000\004\022\167\001\002\000\004\030\170" +
    "\001\002\000\024\004\uffa3\006\uffa3\007\uffa3\012\uffa3\013" +
    "\uffa3\014\uffa3\016\uffa3\025\uffa3\026\uffa3\001\002\000\024" +
    "\004\uffc4\006\uffc4\007\uffc4\012\uffc4\013\uffc4\014\uffc4\016" +
    "\uffc4\025\uffc4\026\uffc4\001\002\000\032\002\uffd4\004\uffd4" +
    "\006\uffd4\007\uffd4\010\uffd4\012\uffd4\013\uffd4\014\uffd4\015" +
    "\uffd4\016\uffd4\025\uffd4\026\uffd4\001\002\000\010\004\150" +
    "\020\131\021\133\001\002\000\004\022\175\001\002\000" +
    "\020\004\164\006\060\012\063\013\057\014\055\016\052" +
    "\025\040\001\002\000\024\004\uffad\006\uffad\007\203\012" +
    "\uffad\013\uffad\014\uffad\016\uffad\025\uffad\026\uffad\001\002" +
    "\000\024\004\uffac\006\uffac\007\200\012\uffac\013\uffac\014" +
    "\uffac\016\uffac\025\uffac\026\uffac\001\002\000\020\004\164" +
    "\006\060\012\063\013\057\014\055\016\052\025\040\001" +
    "\002\000\024\004\uffa9\006\uffa9\007\uffa9\012\uffa9\013\uffa9" +
    "\014\uffa9\016\uffa9\025\uffa9\026\uffa9\001\002\000\024\004" +
    "\uffa8\006\uffa8\007\uffa8\012\uffa8\013\uffa8\014\uffa8\016\uffa8" +
    "\025\uffa8\026\uffa8\001\002\000\020\004\164\006\060\012" +
    "\063\013\057\014\055\016\052\025\040\001\002\000\024" +
    "\004\uffab\006\uffab\007\uffab\012\uffab\013\uffab\014\uffab\016" +
    "\uffab\025\uffab\026\uffab\001\002\000\024\004\uffaa\006\uffaa" +
    "\007\uffaa\012\uffaa\013\uffaa\014\uffaa\016\uffaa\025\uffaa\026" +
    "\uffaa\001\002\000\012\004\150\020\131\021\133\022\207" +
    "\001\002\000\004\030\213\001\002\000\004\022\211\001" +
    "\002\000\004\030\212\001\002\000\024\004\uffa5\006\uffa5" +
    "\007\uffa5\012\uffa5\013\uffa5\014\uffa5\016\uffa5\025\uffa5\026" +
    "\uffa5\001\002\000\024\004\uffa4\006\uffa4\007\uffa4\012\uffa4" +
    "\013\uffa4\014\uffa4\016\uffa4\025\uffa4\026\uffa4\001\002\000" +
    "\024\004\uffa1\006\uffa1\007\uffa1\012\uffa1\013\uffa1\014\uffa1" +
    "\016\uffa1\025\uffa1\026\uffa1\001\002\000\004\030\216\001" +
    "\002\000\024\004\uffa2\006\uffa2\007\uffa2\012\uffa2\013\uffa2" +
    "\014\uffa2\016\uffa2\025\uffa2\026\uffa2\001\002\000\004\026" +
    "\uffcb\001\002\000\010\004\150\020\131\021\133\001\002" +
    "\000\004\022\222\001\002\000\020\004\164\006\060\012" +
    "\063\013\057\014\055\016\052\025\040\001\002\000\024" +
    "\004\uffa7\006\uffa7\007\uffa7\012\uffa7\013\uffa7\014\uffa7\016" +
    "\uffa7\025\uffa7\026\uffa7\001\002\000\024\004\uffa6\006\uffa6" +
    "\007\uffa6\012\uffa6\013\uffa6\014\uffa6\016\uffa6\025\uffa6\026" +
    "\uffa6\001\002\000\004\026\uffd2\001\002\000\004\025\uffdd" +
    "\001\002\000\004\036\uffd8\001\002\000\006\022\236\027" +
    "\235\001\002\000\004\036\233\001\002\000\004\036\uffd9" +
    "\001\002\000\004\004\234\001\002\000\006\022\uffdb\027" +
    "\uffdb\001\002\000\006\004\227\010\232\001\002\000\004" +
    "\025\uffdc\001\002\000\004\036\240\001\002\000\004\004" +
    "\241\001\002\000\006\022\uffda\027\uffda\001\002\000\006" +
    "\027\uffe7\030\uffe7\001\002\000\006\027\uffe6\030\uffe6\001" +
    "\002\000\004\004\246\001\002\000\004\002\ufff5\001\002" +
    "\000\004\021\035\001\002\000\004\004\251\001\002\000" +
    "\026\004\uffea\006\uffea\010\uffea\012\uffea\013\uffea\014\uffea" +
    "\015\uffea\016\uffea\025\uffea\026\uffea\001\002\000\010\027" +
    "\uffe5\030\uffe5\035\252\001\002\000\006\004\254\020\253" +
    "\001\002\000\006\027\uffe4\030\uffe4\001\002\000\006\027" +
    "\uffe3\030\uffe3\001\002\000\004\004\257\001\002\000\026" +
    "\004\uffe9\006\uffe9\010\uffe9\012\uffe9\013\uffe9\014\uffe9\015" +
    "\uffe9\016\uffe9\025\uffe9\026\uffe9\001\002\000\006\027\uffe1" +
    "\030\uffe1\001\002\000\004\021\035\001\002\000\004\021" +
    "\262\001\002\000\004\022\263\001\002\000\004\025\040" +
    "\001\002\000\004\002\uffde\001\002\000\004\025\040\001" +
    "\002\000\006\010\uffdf\015\uffdf\001\002\000\014\021\035" +
    "\023\076\027\uffe8\030\uffe8\035\034\001\002\000\012\004" +
    "\025\005\010\010\012\015\014\001\002\000\004\002\ufffb" +
    "\001\002\000\004\020\273\001\002\000\004\030\ufff3\001" +
    "\002\000\004\030\275\001\002\000\012\004\ufff2\005\ufff2" +
    "\010\ufff2\015\ufff2\001\002\000\004\002\001\001\002" });

  /** Access to parse-action table. */
  public short[][] action_table() {return _action_table;}

  /** <code>reduce_goto</code> table. */
  protected static final short[][] _reduce_table = 
    unpackFromStrings(new String[] {
    "\000\274\000\006\002\003\052\004\001\001\000\002\001" +
    "\001\000\006\045\006\053\005\001\001\000\030\003\022" +
    "\004\017\005\012\006\021\007\016\010\010\012\025\014" +
    "\023\017\015\020\014\021\020\001\001\000\002\001\001" +
    "\000\002\001\001\000\004\054\267\001\001\000\002\001" +
    "\001\000\002\001\001\000\002\001\001\000\002\001\001" +
    "\000\002\001\001\000\002\001\001\000\002\001\001\000" +
    "\010\006\244\007\016\021\020\001\001\000\002\001\001" +
    "\000\002\001\001\000\020\005\031\006\021\007\016\014" +
    "\023\017\015\020\014\021\020\001\001\000\002\001\001" +
    "\000\024\004\026\005\012\006\021\007\016\012\025\014" +
    "\023\017\015\020\014\021\020\001\001\000\002\001\001" +
    "\000\002\001\001\000\002\001\001\000\002\001\001\000" +
    "\004\023\035\001\001\000\002\001\001\000\006\022\230" +
    "\024\227\001\001\000\004\035\036\001\001\000\002\001" +
    "\001\000\006\061\041\062\040\001\001\000\044\011\055" +
    "\012\046\013\043\014\070\017\015\020\014\026\061\030" +
    "\064\034\045\035\052\036\060\037\047\040\063\041\053" +
    "\042\065\043\044\044\050\001\001\000\002\001\001\000" +
    "\002\001\001\000\002\001\001\000\002\001\001\000\002" +
    "\001\001\000\042\011\224\012\046\013\043\014\070\017" +
    "\015\020\014\026\061\030\064\034\045\035\052\037\047" +
    "\040\063\041\053\042\065\043\044\044\050\001\001\000" +
    "\002\001\001\000\002\001\001\000\002\001\001\000\026" +
    "\026\061\030\064\034\045\035\052\037\216\040\063\041" +
    "\053\042\065\043\044\044\050\001\001\000\002\001\001" +
    "\000\012\025\214\026\151\027\150\030\131\001\001\000" +
    "\002\001\001\000\002\001\001\000\002\001\001\000\002" +
    "\001\001\000\002\001\001\000\002\001\001\000\026\026" +
    "\061\030\064\034\045\035\052\037\162\040\063\041\053" +
    "\042\065\043\044\044\050\001\001\000\002\001\001\000" +
    "\002\001\001\000\006\016\112\031\114\001\001\000\002" +
    "\001\001\000\036\013\071\014\070\017\015\020\014\026" +
    "\061\030\064\034\045\035\052\037\047\040\063\041\053" +
    "\042\065\043\044\044\050\001\001\000\002\001\001\000" +
    "\002\001\001\000\002\001\001\000\004\015\076\001\001" +
    "\000\002\001\001\000\004\015\077\001\001\000\004\056" +
    "\100\001\001\000\002\001\001\000\002\001\001\000\004" +
    "\057\106\001\001\000\004\060\104\001\001\000\002\001" +
    "\001\000\002\001\001\000\002\001\001\000\002\001\001" +
    "\000\012\025\157\026\151\027\150\030\131\001\001\000" +
    "\006\027\156\030\131\001\001\000\004\016\126\001\001" +
    "\000\006\032\116\033\120\001\001\000\002\001\001\000" +
    "\002\001\001\000\002\001\001\000\004\016\121\001\001" +
    "\000\002\001\001\000\004\016\122\001\001\000\002\001" +
    "\001\000\004\033\125\001\001\000\002\001\001\000\002" +
    "\001\001\000\002\001\001\000\006\027\134\030\131\001" +
    "\001\000\002\001\001\000\002\001\001\000\012\025\152" +
    "\026\151\027\150\030\131\001\001\000\006\016\145\031" +
    "\114\001\001\000\002\001\001\000\006\027\144\030\131" +
    "\001\001\000\006\027\143\030\131\001\001\000\006\027" +
    "\142\030\131\001\001\000\006\027\141\030\131\001\001" +
    "\000\002\001\001\000\002\001\001\000\002\001\001\000" +
    "\002\001\001\000\004\016\146\001\001\000\002\001\001" +
    "\000\006\016\154\031\114\001\001\000\002\001\001\000" +
    "\002\001\001\000\002\001\001\000\002\001\001\000\004" +
    "\016\155\001\001\000\002\001\001\000\002\001\001\000" +
    "\002\001\001\000\002\001\001\000\002\001\001\000\002" +
    "\001\001\000\006\016\112\031\114\001\001\000\002\001" +
    "\001\000\002\001\001\000\002\001\001\000\002\001\001" +
    "\000\002\001\001\000\002\001\001\000\012\025\173\026" +
    "\151\027\150\030\131\001\001\000\002\001\001\000\024" +
    "\026\061\030\064\034\045\035\176\040\175\041\053\042" +
    "\065\043\044\044\050\001\001\000\002\001\001\000\002" +
    "\001\001\000\024\026\061\030\064\034\045\035\201\040" +
    "\200\041\053\042\065\043\044\044\050\001\001\000\002" +
    "\001\001\000\002\001\001\000\024\026\061\030\064\034" +
    "\045\035\204\040\203\041\053\042\065\043\044\044\050" +
    "\001\001\000\002\001\001\000\002\001\001\000\012\025" +
    "\207\026\151\027\150\030\131\001\001\000\002\001\001" +
    "\000\002\001\001\000\002\001\001\000\002\001\001\000" +
    "\002\001\001\000\002\001\001\000\002\001\001\000\002" +
    "\001\001\000\002\001\001\000\012\025\220\026\151\027" +
    "\150\030\131\001\001\000\002\001\001\000\024\026\061" +
    "\030\064\034\045\035\223\040\222\041\053\042\065\043" +
    "\044\044\050\001\001\000\002\001\001\000\002\001\001" +
    "\000\002\001\001\000\002\001\001\000\002\001\001\000" +
    "\002\001\001\000\002\001\001\000\002\001\001\000\002" +
    "\001\001\000\002\001\001\000\004\022\236\001\001\000" +
    "\002\001\001\000\002\001\001\000\002\001\001\000\002" +
    "\001\001\000\002\001\001\000\002\001\001\000\002\001" +
    "\001\000\002\001\001\000\004\023\035\001\001\000\002" +
    "\001\001\000\002\001\001\000\002\001\001\000\002\001" +
    "\001\000\002\001\001\000\002\001\001\000\002\001\001" +
    "\000\002\001\001\000\002\001\001\000\004\023\264\001" +
    "\001\000\002\001\001\000\002\001\001\000\004\035\263" +
    "\001\001\000\002\001\001\000\004\035\265\001\001\000" +
    "\002\001\001\000\006\015\076\023\035\001\001\000\030" +
    "\003\270\004\017\005\012\006\021\007\016\010\010\012" +
    "\025\014\023\017\015\020\014\021\020\001\001\000\002" +
    "\001\001\000\002\001\001\000\004\055\273\001\001\000" +
    "\002\001\001\000\002\001\001\000\002\001\001" });

  /** Access to <code>reduce_goto</code> table. */
  public short[][] reduce_table() {return _reduce_table;}

  /** Instance of action encapsulation class. */
  protected CUP$parser$actions action_obj;

  /** Action encapsulation object initializer. */
  protected void init_actions()
    {
      action_obj = new CUP$parser$actions(this);
    }

  /** Invoke a user supplied parse action. */
  public java_cup.runtime.Symbol do_action(
    int                        act_num,
    java_cup.runtime.lr_parser parser,
    java.util.Stack            stack,
    int                        top)
    throws java.lang.Exception
  {
    /* call code in generated class */
    return action_obj.CUP$parser$do_action(act_num, parser, stack, top);
  }

  /** Indicates start state. */
  public int start_state() {return 0;}
  /** Indicates start production. */
  public int start_production() {return 0;}

  /** <code>EOF</code> Symbol index. */
  public int EOF_sym() {return 0;}

  /** <code>error</code> Symbol index. */
  public int error_sym() {return 1;}



	SyntaxErrorManager        syntaxErrorManager   = CompilerContext.getSyntaxErrorManager();
	
	
	public void syntax_error(Symbol symbol)
	{

	    Token token = (Token) symbol.value;
	    syntaxErrorManager.syntaxError ("Error sintactico", token);	    
	}
		
	public void unrecovered_syntax_error(java_cup.runtime.Symbol symbol)
	{	
	    Token token = (Token) symbol.value;
	    syntaxErrorManager.syntaxFatalError ("Error fatal", token);
	    
	}

}

/** Cup generated class to encapsulate user supplied action code.*/
class CUP$parser$actions {


	
	SyntaxErrorManager        syntaxErrorManager   = CompilerContext.getSyntaxErrorManager();
	SemanticErrorManager      semanticErrorManager = CompilerContext.getSemanticErrorManager ();
	ScopeManagerIF            scopeManager         = CompilerContext.getScopeManager ();
	FinalCodeFactoryIF        finalCodeFactory     = CompilerContext.getFinalCodeFactory ();


  private final parser parser;

  /** Constructor */
  CUP$parser$actions(parser parser) {
    this.parser = parser;
  }

  /** Method with the actual generated action code. */
  public final java_cup.runtime.Symbol CUP$parser$do_action(
    int                        CUP$parser$act_num,
    java_cup.runtime.lr_parser CUP$parser$parser,
    java.util.Stack            CUP$parser$stack,
    int                        CUP$parser$top)
    throws java.lang.Exception
    {
      /* Symbol object for return from actions */
      java_cup.runtime.Symbol CUP$parser$result;

      /* select the action based on the action number */
      switch (CUP$parser$act_num)
        {
          /*. . . . . . . . . . . . . . . . . . . .*/
          case 96: // retorno_funcion ::= RETURN PUNTOYCOMA 
            {
              Object RESULT =null;

              CUP$parser$result = parser.getSymbolFactory().newSymbol("retorno_funcion",26, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 95: // retorno_funcion ::= RETURN expresion PUNTOYCOMA 
            {
              Object RESULT =null;

              CUP$parser$result = parser.getSymbolFactory().newSymbol("retorno_funcion",26, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 94: // sentencia_printc ::= PRINTC PARIZQ CADENA PARDER PUNTOYCOMA 
            {
              Object RESULT =null;

              CUP$parser$result = parser.getSymbolFactory().newSymbol("sentencia_printc",34, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-4)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 93: // sentencia_printi ::= PRINTI PARIZQ PARDER PUNTOYCOMA 
            {
              Object RESULT =null;

              CUP$parser$result = parser.getSymbolFactory().newSymbol("sentencia_printi",33, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-3)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 92: // sentencia_printi ::= PRINTI PARIZQ expresion PARDER PUNTOYCOMA 
            {
              Object RESULT =null;

              CUP$parser$result = parser.getSymbolFactory().newSymbol("sentencia_printi",33, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-4)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 91: // sentencia_while ::= WHILE PARIZQ expresion PARDER bloque_sentencias 
            {
              Object RESULT =null;
		int pleft = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-3)).left;
		int pright = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-3)).right;
		Token p = (Token)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-3)).value;
		int exleft = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)).left;
		int exright = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)).right;
		Object ex = (Object)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-2)).value;
		int bloqueleft = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).left;
		int bloqueright = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).right;
		Object bloque = (Object)((java_cup.runtime.Symbol) CUP$parser$stack.peek()).value;
		
						
						Expresion expresion = (Expresion)ex;

					if (expresion.getValor()==0 || expresion.getValor()==1) {
						Sentencia_While sWhile = new Sentencia_While();
						sWhile.setS1((Bloque_sentencias)bloque);
						RESULT = sWhile;
					}

					else
						semanticErrorManager.semanticFatalError("Error. Se esperaba una expresion logica en la linea " + p.getLine());
					
					
					
              CUP$parser$result = parser.getSymbolFactory().newSymbol("sentencia_while",32, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-4)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 90: // sentencia_while ::= WHILE PARIZQ expresion PARDER sentencia 
            {
              Object RESULT =null;
		int pleft = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-3)).left;
		int pright = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-3)).right;
		Token p = (Token)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-3)).value;
		int exleft = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)).left;
		int exright = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)).right;
		Object ex = (Object)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-2)).value;
		int senleft = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).left;
		int senright = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).right;
		Object sen = (Object)((java_cup.runtime.Symbol) CUP$parser$stack.peek()).value;
		
	

	Expresion expresion = (Expresion)ex;

	if (expresion.getValor()==0 || expresion.getValor()==1) {
		Sentencia_While sWhile = new Sentencia_While();
		sWhile.setS1((Bloque_sentencias)sen);
		RESULT = sWhile;
	}

	else
		semanticErrorManager.semanticFatalError("Error. Se esperaba una expresion logica en la linea " + p.getLine());





              CUP$parser$result = parser.getSymbolFactory().newSymbol("sentencia_while",32, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-4)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 89: // sentencia_if ::= IF PARIZQ expresion PARDER bloque_sentencias ELSE bloque_sentencias 
            {
              Object RESULT =null;
		int pleft = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-5)).left;
		int pright = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-5)).right;
		Token p = (Token)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-5)).value;
		int exleft = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-4)).left;
		int exright = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-4)).right;
		Object ex = (Object)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-4)).value;
		int bloque1left = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)).left;
		int bloque1right = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)).right;
		Object bloque1 = (Object)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-2)).value;
		int bloque2left = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).left;
		int bloque2right = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).right;
		Object bloque2 = (Object)((java_cup.runtime.Symbol) CUP$parser$stack.peek()).value;
		
						Expresion expresion = (Expresion)ex;
					
						if (expresion.getValor()==0 || expresion.getValor()==1) {
							SentenciaIF sIF = new SentenciaIF((Expresion)ex, true);
							sIF.setS1((Bloque_sentencias)bloque1);
							sIF.setS2((Bloque_sentencias)bloque1);
							RESULT = sIF;
				}

				else
					semanticErrorManager.semanticFatalError("Error. Se esperaba una expresion logica en la linea " + p.getLine());
					
						
						
						
						
              CUP$parser$result = parser.getSymbolFactory().newSymbol("sentencia_if",31, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-6)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 88: // sentencia_if ::= IF PARIZQ expresion PARDER bloque_sentencias ELSE sentencia 
            {
              Object RESULT =null;
		int pleft = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-5)).left;
		int pright = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-5)).right;
		Token p = (Token)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-5)).value;
		int exleft = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-4)).left;
		int exright = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-4)).right;
		Object ex = (Object)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-4)).value;
		int bloqueleft = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)).left;
		int bloqueright = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)).right;
		Object bloque = (Object)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-2)).value;
		int senleft = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).left;
		int senright = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).right;
		Object sen = (Object)((java_cup.runtime.Symbol) CUP$parser$stack.peek()).value;
		
						Expresion expresion = (Expresion)ex;
					
						if (expresion.getValor()==0 || expresion.getValor()==1) {
							SentenciaIF sIF = new SentenciaIF((Expresion)ex, true);
							sIF.setS1((Bloque_sentencias)bloque);
							sIF.setS2((Bloque_sentencias)sen);
							RESULT = sIF;
				}

				else
					semanticErrorManager.semanticFatalError("Error. Se esperaba una expresion logica en la linea " + p.getLine());
					
						
						
						
						
              CUP$parser$result = parser.getSymbolFactory().newSymbol("sentencia_if",31, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-6)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 87: // sentencia_if ::= IF PARIZQ expresion PARDER sentencia ELSE bloque_sentencias 
            {
              Object RESULT =null;
		int pleft = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-5)).left;
		int pright = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-5)).right;
		Token p = (Token)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-5)).value;
		int exleft = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-4)).left;
		int exright = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-4)).right;
		Object ex = (Object)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-4)).value;
		int senleft = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)).left;
		int senright = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)).right;
		Object sen = (Object)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-2)).value;
		int bloqueleft = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).left;
		int bloqueright = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).right;
		Object bloque = (Object)((java_cup.runtime.Symbol) CUP$parser$stack.peek()).value;
		
						Expresion expresion = (Expresion)ex;
				
						if (expresion.getValor()==0 || expresion.getValor()==1) {
							SentenciaIF sIF = new SentenciaIF((Expresion)ex, true);
							sIF.setS1((Bloque_sentencias)sen);
							sIF.setS2((Bloque_sentencias)bloque);
							RESULT = sIF;
					}

					else
						semanticErrorManager.semanticFatalError("Error. Se esperaba una expresion logica en la linea " + p.getLine());
						
						
						
              CUP$parser$result = parser.getSymbolFactory().newSymbol("sentencia_if",31, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-6)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 86: // sentencia_if ::= IF PARIZQ expresion PARDER sentencia ELSE sentencia 
            {
              Object RESULT =null;
		int pleft = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-5)).left;
		int pright = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-5)).right;
		Token p = (Token)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-5)).value;
		int exleft = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-4)).left;
		int exright = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-4)).right;
		Object ex = (Object)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-4)).value;
		int s1left = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)).left;
		int s1right = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)).right;
		Object s1 = (Object)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-2)).value;
		int s2left = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).left;
		int s2right = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).right;
		Object s2 = (Object)((java_cup.runtime.Symbol) CUP$parser$stack.peek()).value;
		
						
						Expresion expresion = (Expresion)ex;
						if (expresion.getValor()==0 || expresion.getValor()==1) {
							SentenciaIF sIF = new SentenciaIF((Expresion)ex, true);
							sIF.setS1((Bloque_sentencias)s1);
							sIF.setS2((Bloque_sentencias)s2);
							RESULT = sIF;
						}
	
						else
							semanticErrorManager.semanticFatalError("Error. Se esperaba una expresion logica en la linea " + p.getLine());

				
				
				
              CUP$parser$result = parser.getSymbolFactory().newSymbol("sentencia_if",31, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-6)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 85: // sentencia_if ::= IF PARIZQ expresion PARDER bloque_sentencias 
            {
              Object RESULT =null;
		int pleft = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-3)).left;
		int pright = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-3)).right;
		Token p = (Token)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-3)).value;
		int exleft = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)).left;
		int exright = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)).right;
		Object ex = (Object)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-2)).value;
		int sleft = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).left;
		int sright = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).right;
		Object s = (Object)((java_cup.runtime.Symbol) CUP$parser$stack.peek()).value;
		
						
					Expresion expresion = (Expresion)ex;	
					if (expresion.getValor()==0 || expresion.getValor()==1) {
	
						SentenciaIF sIF = new SentenciaIF((Expresion)ex, false);
						sIF.setS1((Bloque_sentencias)s);
						RESULT = sIF;
					}
					
					else
						semanticErrorManager.semanticFatalError("Error. Se esperaba una expresion logica en la linea " + p.getLine());
				
				
              CUP$parser$result = parser.getSymbolFactory().newSymbol("sentencia_if",31, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-4)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 84: // sentencia_if ::= IF PARIZQ expresion PARDER sentencia 
            {
              Object RESULT =null;
		int pleft = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-3)).left;
		int pright = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-3)).right;
		Token p = (Token)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-3)).value;
		int exleft = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)).left;
		int exright = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)).right;
		Object ex = (Object)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-2)).value;
		int senleft = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).left;
		int senright = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).right;
		Object sen = (Object)((java_cup.runtime.Symbol) CUP$parser$stack.peek()).value;
		
			Expresion expresion = (Expresion)ex;
			
			if (expresion.getValor()==0 || expresion.getValor()==1) {
				SentenciaIF sIF = new SentenciaIF((Expresion)ex, false);
				sIF.setS1((Bloque_sentencias)sen);
				RESULT = sIF;
			}
			else
				semanticErrorManager.semanticFatalError("Error. Se esperaba una expresion logica en la linea " + p.getLine());

	
	
	
              CUP$parser$result = parser.getSymbolFactory().newSymbol("sentencia_if",31, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-4)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 83: // parametro ::= IDENTIFICADOR rango_matriz rango_matriz 
            {
              Object RESULT =null;

              CUP$parser$result = parser.getSymbolFactory().newSymbol("parametro",25, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 82: // parametro ::= IDENTIFICADOR 
            {
              Object RESULT =null;

              CUP$parser$result = parser.getSymbolFactory().newSymbol("parametro",25, ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 81: // parametros ::= parametros COMA parametro 
            {
              Object RESULT =null;

              CUP$parser$result = parser.getSymbolFactory().newSymbol("parametros",24, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 80: // parametros ::= parametro 
            {
              Object RESULT =null;

              CUP$parser$result = parser.getSymbolFactory().newSymbol("parametros",24, ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 79: // lista_parametros ::= PARIZQ parametros PARDER 
            {
              Object RESULT =null;

              CUP$parser$result = parser.getSymbolFactory().newSymbol("lista_parametros",23, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 78: // lista_parametros ::= PARIZQ PARDER 
            {
              Object RESULT =null;

              CUP$parser$result = parser.getSymbolFactory().newSymbol("lista_parametros",23, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 77: // llamada_funcion ::= IDENTIFICADOR lista_parametros 
            {
              Object RESULT =null;

              CUP$parser$result = parser.getSymbolFactory().newSymbol("llamada_funcion",22, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 76: // expresion ::= asignacion 
            {
              Object RESULT =null;
		int asigleft = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).left;
		int asigright = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).right;
		Object asig = (Object)((java_cup.runtime.Symbol) CUP$parser$stack.peek()).value;
		
					RESULT=asig;
					
					
              CUP$parser$result = parser.getSymbolFactory().newSymbol("expresion",19, ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 75: // expresion ::= expresion_sin_asign 
            {
              Object RESULT =null;
		int exleft = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).left;
		int exright = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).right;
		Object ex = (Object)((java_cup.runtime.Symbol) CUP$parser$stack.peek()).value;
		 
		
			RESULT=ex;
		
			
	
              CUP$parser$result = parser.getSymbolFactory().newSymbol("expresion",19, ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 74: // expresion_sin_asign ::= PARIZQ expresion PARDER 
            {
              Object RESULT =null;
		int expleft = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)).left;
		int expright = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)).right;
		Object exp = (Object)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-1)).value;
		
							RESULT= exp;
							
              CUP$parser$result = parser.getSymbolFactory().newSymbol("expresion_sin_asign",21, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 73: // expresion_sin_asign ::= expresion_sin_asign AND expresion_sin_asign 
            {
              Object RESULT =null;
		int ex1left = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)).left;
		int ex1right = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)).right;
		Object ex1 = (Object)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-2)).value;
		int aleft = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)).left;
		int aright = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)).right;
		Token a = (Token)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-1)).value;
		int ex2left = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).left;
		int ex2right = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).right;
		Object ex2 = (Object)((java_cup.runtime.Symbol) CUP$parser$stack.peek()).value;
		
						
							Expresion exp1 = (Expresion)ex1;
							Expresion exp2 = (Expresion)ex2;
							int valor;
							boolean valor1=false;
							boolean valor2=false;
							
							if (exp1.getValor()==1)
								valor1 = true;
							else {
								if (exp1.getValor()==0)
									valor1 = false;
								else
									semanticErrorManager.semanticFatalError("Error. El valor " + exp1.getValor() + " no es un valor lógico en la linea " + a.getLine());
								}
							
							if (exp2.getValor()==1)
								valor2 = true;
							else {
								if (exp2.getValor()==0)
									valor2 = false;
								else
									semanticErrorManager.semanticFatalError("Error. El valor " + exp2.getValor() + " no es un valor lógico en la linea " + a.getLine());
								}
							
							
							if (valor1 && valor2)
								valor=1;
							else
								valor=0;
							
							ExpresionCompuesta expCompuesta = new ExpresionCompuesta(valor, "tipoCompuesto",(Expresion) ex1,(Expresion) ex2);
						
					
							RESULT = expCompuesta;
							
							
              CUP$parser$result = parser.getSymbolFactory().newSymbol("expresion_sin_asign",21, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 72: // expresion_sin_asign ::= expresion_sin_asign DISTINTO expresion_sin_asign 
            {
              Object RESULT =null;
		int ex1left = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)).left;
		int ex1right = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)).right;
		Object ex1 = (Object)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-2)).value;
		int ex2left = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).left;
		int ex2right = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).right;
		Object ex2 = (Object)((java_cup.runtime.Symbol) CUP$parser$stack.peek()).value;
		
							
							Expresion exp1 = (Expresion)ex1;
							Expresion exp2 = (Expresion)ex2;
							int valor;
							if (exp1.getValor() != exp2.getValor())
								valor=1;
							else
								valor=0;
							ExpresionCompuesta expCompuesta = new ExpresionCompuesta(valor,"tipoCompuesto", (Expresion)ex1,(Expresion)ex2);
							
						
							RESULT = expCompuesta;
						
							
							
							
              CUP$parser$result = parser.getSymbolFactory().newSymbol("expresion_sin_asign",21, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 71: // expresion_sin_asign ::= expresion_sin_asign MENOR expresion_sin_asign 
            {
              Object RESULT =null;
		int ex1left = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)).left;
		int ex1right = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)).right;
		Object ex1 = (Object)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-2)).value;
		int ex2left = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).left;
		int ex2right = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).right;
		Object ex2 = (Object)((java_cup.runtime.Symbol) CUP$parser$stack.peek()).value;
		
						
							Expresion exp1 = (Expresion)ex1;
							Expresion exp2 = (Expresion)ex2;
							int valor;
							if (exp1.getValor() < exp2.getValor())
								valor=1;
							else
								valor=0;
							ExpresionCompuesta expCompuesta = new ExpresionCompuesta(valor,"tipoCompuesto", (Expresion)ex1, (Expresion)ex2);
							
							
							RESULT = expCompuesta;
						
							
              CUP$parser$result = parser.getSymbolFactory().newSymbol("expresion_sin_asign",21, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 70: // expresion_sin_asign ::= expresion_sin_asign MAS expresion_sin_asign 
            {
              Object RESULT =null;
		int ex1left = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)).left;
		int ex1right = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)).right;
		Object ex1 = (Object)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-2)).value;
		int masleft = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)).left;
		int masright = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)).right;
		Token mas = (Token)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-1)).value;
		int ex2left = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).left;
		int ex2right = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).right;
		Object ex2 = (Object)((java_cup.runtime.Symbol) CUP$parser$stack.peek()).value;
		
							Expresion exp1 = (Expresion)ex1;
 							Expresion exp2 = (Expresion)ex2;
							ExpresionCompuesta expCompuesta = new ExpresionCompuesta(exp1.getValor()+exp2.getValor(),"tipoCompuesto", (Expresion)ex1, (Expresion)ex2);
 							
								
								RESULT= expCompuesta;
					
							
							
							
              CUP$parser$result = parser.getSymbolFactory().newSymbol("expresion_sin_asign",21, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 69: // expresion_sin_asign ::= llamada_funcion 
            {
              Object RESULT =null;

              CUP$parser$result = parser.getSymbolFactory().newSymbol("expresion_sin_asign",21, ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 68: // expresion_sin_asign ::= IDENTIFICADOR rango_matriz rango_matriz 
            {
              Object RESULT =null;
		int idleft = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)).left;
		int idright = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)).right;
		Token id = (Token)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-2)).value;
		int r1left = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)).left;
		int r1right = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)).right;
		Object r1 = (Object)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-1)).value;
		int r2left = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).left;
		int r2right = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).right;
		Object r2 = (Object)((java_cup.runtime.Symbol) CUP$parser$stack.peek()).value;
		
							ScopeIF sc = scopeManager.getCurrentScope();
 							SymbolTableIF ts = sc.getSymbolTable();
 							if (scopeManager.containsSymbol(id.getLexema())) {
 								SymbolMatrix sMatrix = (SymbolMatrix)scopeManager.searchSymbol(id.getLexema());
 								if (sMatrix.rangoCorrecto((int)r1,(int)r2)) {
 									if (sMatrix.getDefinido((int)r1,(int)r2)) {
 										ExpresionMatriz expMatriz = new ExpresionMatriz(sMatrix.getValor((int)r1,(int)r2),id.getLexema(),(int)r1,(int)r2);
 										RESULT= expMatriz;
 									}
 									else
 	 									semanticErrorManager.semanticFatalError("Error. La posicion [" + (int)r1 + "][" + (int)r2 + "] de la matriz "+ id.getLexema() + " no esta definida en la linea " + id.getLine());

 									
 								
 								}
 								else
 									semanticErrorManager.semanticFatalError("Error. La matriz " + id.getLexema() + " esta fuera de rango en la linea " + id.getLine());
 							
 							}	
 						
 							else {
 								semanticErrorManager.semanticFatalError("Error. La matriz " + id.getLexema() + " no ha sido declarada en la linea " + id.getLine());
 							}
 						
							
							
							
              CUP$parser$result = parser.getSymbolFactory().newSymbol("expresion_sin_asign",21, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 67: // expresion_sin_asign ::= IDENTIFICADOR 
            {
              Object RESULT =null;
		int idleft = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).left;
		int idright = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).right;
		Token id = (Token)((java_cup.runtime.Symbol) CUP$parser$stack.peek()).value;
		
							ScopeIF sc = scopeManager.getCurrentScope();
 							SymbolTableIF ts = sc.getSymbolTable();
 						if (scopeManager.containsSymbol(id.getLexema())) {
 							SymbolIF simbolo = scopeManager.searchSymbol(id.getLexema());
 							if (((simbolo.getType()).getName()).equals("Entero")) {
 								if (simbolo instanceof SymbolVariable) {
 									 ExpresionId expId = new ExpresionId(((SymbolVariable)simbolo).getValor(),id.getLexema());
 									 RESULT = expId;
 								}

								else {
									 ExpresionId expId = new ExpresionId(((SymbolConstant)simbolo).getValor(),id.getLexema());
 									 RESULT = expId;

								}
 							}
 							else
 									semanticErrorManager.semanticFatalError("Error. Identificador no válido " + id.getLexema() + " en la linea " + id.getLine());
 									
								
							
 						}
 						
 						else
 							semanticErrorManager.semanticFatalError("Error. Identificador " + id.getLexema() + " no encontrado en la linea " + id.getLine());
							
              CUP$parser$result = parser.getSymbolFactory().newSymbol("expresion_sin_asign",21, ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 66: // expresion_sin_asign ::= NUMERO 
            {
              Object RESULT =null;
		int numleft = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).left;
		int numright = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).right;
		Token num = (Token)((java_cup.runtime.Symbol) CUP$parser$stack.peek()).value;
		
			if (TypeSimple.rangoCorrecto(Integer.parseInt(num.getLexema()))){
				Expresion exp = new Expresion(Integer.parseInt(num.getLexema()),"tipoEntero");
				RESULT= exp;
				}
			else
				semanticErrorManager.semanticFatalError("Error. El número " + num.getLexema() + " esta fuera de rango en la linea " + num.getLine());

				
				
	
              CUP$parser$result = parser.getSymbolFactory().newSymbol("expresion_sin_asign",21, ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 65: // asignacion ::= IDENTIFICADOR rango_matriz rango_matriz ASIGNACION expresion_sin_asign 
            {
              Object RESULT =null;
		int idleft = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-4)).left;
		int idright = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-4)).right;
		Token id = (Token)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-4)).value;
		int r1left = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-3)).left;
		int r1right = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-3)).right;
		Object r1 = (Object)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-3)).value;
		int r2left = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)).left;
		int r2right = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)).right;
		Object r2 = (Object)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-2)).value;
		int exleft = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).left;
		int exright = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).right;
		Object ex = (Object)((java_cup.runtime.Symbol) CUP$parser$stack.peek()).value;
		
 						
 						ScopeIF sc = scopeManager.getCurrentScope();
 						SymbolTableIF ts = sc.getSymbolTable();
 						if (scopeManager.containsSymbol(id.getLexema())) {
 							SymbolMatrix sMatrix = (SymbolMatrix)scopeManager.searchSymbol(id.getLexema());
 							if (sMatrix.rangoCorrecto((int)r1,(int)r2)) {
 								sMatrix.setValor((int)r1,(int)r2, ((Expresion)ex).getValor());
 								ts.addSymbol(sMatrix);
 								ExpresionMatriz exp1 = new ExpresionMatriz(((Expresion)ex).getValor(),id.getLexema(), (int)r1,(int)r2);
								ExpresionCompuesta expCompuesta = new ExpresionCompuesta(((Expresion)ex).getValor(), "tipoAsignacion", exp1, (Expresion)ex);
								
 								
 							}
 							else
 								semanticErrorManager.semanticFatalError("Error. La matriz " + id.getLexema() + " esta fuera de rango en la linea " + id.getLine());
 							
 						}	
 						
 						else {
 							semanticErrorManager.semanticFatalError("Error. La matriz " + id.getLexema() + " no ha sido declarada en la linea " + id.getLine());
 						}
 						
 						
 						
              CUP$parser$result = parser.getSymbolFactory().newSymbol("asignacion",20, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-4)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 64: // asignacion ::= IDENTIFICADOR ASIGNACION expresion_sin_asign 
            {
              Object RESULT =null;
		int idleft = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)).left;
		int idright = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)).right;
		Token id = (Token)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-2)).value;
		int exleft = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).left;
		int exright = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).right;
		Object ex = (Object)((java_cup.runtime.Symbol) CUP$parser$stack.peek()).value;
		 	
					ScopeIF sc = scopeManager.getCurrentScope();
					SymbolTableIF ts = sc.getSymbolTable();
						if (scopeManager.containsSymbol(id.getLexema())) {
							SymbolIF simbolo = scopeManager.searchSymbol(id.getLexema());
							if (((simbolo.getType()).getName()).equals("Entero")) {
								if (simbolo instanceof SymbolVariable) {
									SymbolVariable sVariable = (SymbolVariable)simbolo;
									sVariable.setValor(((Expresion)ex).getValor());
									ts.addSymbol(sVariable);
									ExpresionId exp1 = new ExpresionId(((Expresion)ex).getValor(),id.getLexema());
									ExpresionCompuesta expCompuesta = new ExpresionCompuesta(((Expresion)ex).getValor(), "tipoAsignacion", exp1, (Expresion)ex);
									
									System.out.println(ts);
									RESULT = expCompuesta; 
								}

								else {
									semanticErrorManager.semanticFatalError("Error. No se puede asignar un valor a la constante " + id.getLexema() + " en la linea " + id.getLine());

								}
							}
							else
								semanticErrorManager.semanticFatalError("Error. Identificador no válido " + id.getLexema() + " en la linea " + id.getLine());
			
	

						}
					
						
              CUP$parser$result = parser.getSymbolFactory().newSymbol("asignacion",20, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 63: // sentencia ::= retorno_funcion 
            {
              Object RESULT =null;

              CUP$parser$result = parser.getSymbolFactory().newSymbol("sentencia",30, ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 62: // sentencia ::= llamada_funcion PUNTOYCOMA 
            {
              Object RESULT =null;

              CUP$parser$result = parser.getSymbolFactory().newSymbol("sentencia",30, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 61: // sentencia ::= asignacion PUNTOYCOMA 
            {
              Object RESULT =null;

              CUP$parser$result = parser.getSymbolFactory().newSymbol("sentencia",30, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 60: // sentencia ::= sentencia_printc 
            {
              Object RESULT =null;

              CUP$parser$result = parser.getSymbolFactory().newSymbol("sentencia",30, ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 59: // sentencia ::= sentencia_printi 
            {
              Object RESULT =null;

              CUP$parser$result = parser.getSymbolFactory().newSymbol("sentencia",30, ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 58: // sentencia ::= sentencia_while 
            {
              Object RESULT =null;

              CUP$parser$result = parser.getSymbolFactory().newSymbol("sentencia",30, ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 57: // sentencia ::= sentencia_if 
            {
              Object RESULT =null;

              CUP$parser$result = parser.getSymbolFactory().newSymbol("sentencia",30, ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 56: // sentencias ::= sentencia sentencias 
            {
              Object RESULT =null;

              CUP$parser$result = parser.getSymbolFactory().newSymbol("sentencias",29, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 55: // sentencias ::= sentencia 
            {
              Object RESULT =null;

              CUP$parser$result = parser.getSymbolFactory().newSymbol("sentencias",29, ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 54: // sentencias ::= bloque_sentencias sentencias 
            {
              Object RESULT =null;

              CUP$parser$result = parser.getSymbolFactory().newSymbol("sentencias",29, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 53: // sentencias ::= bloque_sentencias 
            {
              Object RESULT =null;

              CUP$parser$result = parser.getSymbolFactory().newSymbol("sentencias",29, ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 52: // declar_variables ::= sentencias 
            {
              Object RESULT =null;

              CUP$parser$result = parser.getSymbolFactory().newSymbol("declar_variables",9, ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 51: // declar_variables ::= declar_variable 
            {
              Object RESULT =null;

              CUP$parser$result = parser.getSymbolFactory().newSymbol("declar_variables",9, ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 50: // declar_variables ::= declar_variable declar_variables 
            {
              Object RESULT =null;

              CUP$parser$result = parser.getSymbolFactory().newSymbol("declar_variables",9, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 49: // declar_tipos ::= declar_variables 
            {
              Object RESULT =null;

              CUP$parser$result = parser.getSymbolFactory().newSymbol("declar_tipos",7, ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 48: // declar_tipos ::= declar_tipo 
            {
              Object RESULT =null;

              CUP$parser$result = parser.getSymbolFactory().newSymbol("declar_tipos",7, ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 47: // declar_tipos ::= declar_tipo declar_tipos 
            {
              Object RESULT =null;

              CUP$parser$result = parser.getSymbolFactory().newSymbol("declar_tipos",7, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 46: // cuerpo_sentencias ::= declar_tipos 
            {
              Object RESULT =null;

              CUP$parser$result = parser.getSymbolFactory().newSymbol("cuerpo_sentencias",28, ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 45: // bloque_sentencias ::= LLAVEIZQ NT$8 cuerpo_sentencias LLAVEDER 
            {
              Object RESULT =null;
              // propagate RESULT from NT$8
                RESULT = (Object) ((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-2)).value;
		
		scopeManager.closeScope();
		ScopeIF ambito = scopeManager.getCurrentScope();
		System.out.println("Tras cerrar bloque NO vacio"+ ambito);
		
              CUP$parser$result = parser.getSymbolFactory().newSymbol("bloque_sentencias",27, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-3)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 44: // NT$8 ::= 
            {
              Object RESULT =null;

	ScopeIF ambito = scopeManager.openScope();
	System.out.println("Tras abrir bloque NO vacio"+ ambito);
	
              CUP$parser$result = parser.getSymbolFactory().newSymbol("NT$8",48, ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 43: // bloque_sentencias ::= LLAVEIZQ NT$7 LLAVEDER 
            {
              Object RESULT =null;
              // propagate RESULT from NT$7
                RESULT = (Object) ((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-1)).value;

              CUP$parser$result = parser.getSymbolFactory().newSymbol("bloque_sentencias",27, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 42: // NT$7 ::= 
            {
              Object RESULT =null;

	ScopeIF ambito = scopeManager.openScope();
	System.out.println("Tras abrir bloque vacio"+ ambito);
	scopeManager.closeScope();ambito = scopeManager.getCurrentScope();
	System.out.println("Tras cerrar bloque vacio"+ ambito);
	
              CUP$parser$result = parser.getSymbolFactory().newSymbol("NT$7",47, ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 41: // tipo_parametros ::= IDENTIFICADOR 
            {
              Object RESULT =null;

              CUP$parser$result = parser.getSymbolFactory().newSymbol("tipo_parametros",16, ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 40: // tipo_parametros ::= ENTERO 
            {
              Object RESULT =null;

              CUP$parser$result = parser.getSymbolFactory().newSymbol("tipo_parametros",16, ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 39: // lista_declar_parametros ::= lista_declar_parametros COMA tipo_parametros REFERENCIA IDENTIFICADOR 
            {
              Object RESULT =null;

              CUP$parser$result = parser.getSymbolFactory().newSymbol("lista_declar_parametros",18, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-4)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 38: // lista_declar_parametros ::= tipo_parametros REFERENCIA IDENTIFICADOR 
            {
              Object RESULT =null;

              CUP$parser$result = parser.getSymbolFactory().newSymbol("lista_declar_parametros",18, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 37: // declar_parametros ::= PARIZQ lista_declar_parametros PARDER 
            {
              Object RESULT =null;

              CUP$parser$result = parser.getSymbolFactory().newSymbol("declar_parametros",17, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 36: // declar_parametros ::= PARIZQ PARDER 
            {
              Object RESULT =null;

              CUP$parser$result = parser.getSymbolFactory().newSymbol("declar_parametros",17, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 35: // declar_main ::= VOID MAIN PARIZQ PARDER bloque_sentencias 
            {
              Object RESULT =null;

              CUP$parser$result = parser.getSymbolFactory().newSymbol("declar_main",5, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-4)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 34: // declar_funcion ::= VOID IDENTIFICADOR declar_parametros bloque_sentencias 
            {
              Object RESULT =null;

              CUP$parser$result = parser.getSymbolFactory().newSymbol("declar_funcion",15, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-3)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 33: // declar_funcion ::= ENTERO IDENTIFICADOR declar_parametros bloque_sentencias 
            {
              Object RESULT =null;

              CUP$parser$result = parser.getSymbolFactory().newSymbol("declar_funcion",15, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-3)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 32: // lista_variables_matriz ::= lista_variables_matriz COMA IDENTIFICADOR 
            {
              Object RESULT =null;
		int matricesleft = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)).left;
		int matricesright = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)).right;
		Object matrices = (Object)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-2)).value;
		int idleft = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).left;
		int idright = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).right;
		Token id = (Token)((java_cup.runtime.Symbol) CUP$parser$stack.peek()).value;
		
	
	Lista_variables_matriz listaMat = (Lista_variables_matriz) matrices;
	ScopeIF sc = scopeManager.getCurrentScope();
	SymbolTableIF ts = sc.getSymbolTable();
	TypeTableIF tt = sc.getTypeTable();

	
	if (ts.containsSymbol(id.getLexema())){
		semanticErrorManager.semanticFatalError("Error. La matriz " + id.getLexema() + " ya ha sido declarada en la linea " + id.getLine());
	}

	else {
		
		if (tt.containsType(listaMat.getTypeName())) {
			TypeArray tipo = (TypeArray)tt.getType(listaMat.getTypeName());
			listaMat.addMatriz(id.getLexema());
			SymbolMatrix mat = new SymbolMatrix(sc,id.getLexema(),tipo,tipo.getR1(),tipo.getR2());
			ts.addSymbol(mat);
			System.out.println(ts);
				
			}
		
		}



              CUP$parser$result = parser.getSymbolFactory().newSymbol("lista_variables_matriz",14, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 31: // lista_variables_matriz ::= IDENTIFICADOR IDENTIFICADOR 
            {
              Object RESULT =null;
		int id1left = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)).left;
		int id1right = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)).right;
		Token id1 = (Token)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-1)).value;
		int id2left = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).left;
		int id2right = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).right;
		Token id2 = (Token)((java_cup.runtime.Symbol) CUP$parser$stack.peek()).value;
		
	
	ScopeIF sc = scopeManager.getCurrentScope();
	SymbolTableIF ts = sc.getSymbolTable();
	TypeTableIF tt = sc.getTypeTable();

	
	if (ts.containsSymbol(id2.getLexema())){
		semanticErrorManager.semanticFatalError("Error. La matriz " + id2.getLexema() + " ya ha sido declarada en la linea " + id2.getLine());
	}
	else {
		
			if (tt.containsType(id1.getLexema())) {
				TypeArray tipo = (TypeArray)tt.getType(id1.getLexema());
				Lista_variables_matriz listaMat = new Lista_variables_matriz(tipo.getR1(), tipo.getR2(), id1.getLexema());
				listaMat.addMatriz(id2.getLexema());
				SymbolMatrix mat = new SymbolMatrix(sc,id2.getLexema(),tipo,tipo.getR1(),tipo.getR2());
				ts.addSymbol(mat);
				RESULT = listaMat;
				
			}
		
		}



              CUP$parser$result = parser.getSymbolFactory().newSymbol("lista_variables_matriz",14, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 30: // lista_variables_enteras ::= lista_variables_enteras COMA IDENTIFICADOR ASIGNACION IDENTIFICADOR 
            {
              Object RESULT =null;
		int varleft = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-4)).left;
		int varright = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-4)).right;
		Object var = (Object)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-4)).value;
		int id1left = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)).left;
		int id1right = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)).right;
		Token id1 = (Token)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-2)).value;
		int id2left = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).left;
		int id2right = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).right;
		Token id2 = (Token)((java_cup.runtime.Symbol) CUP$parser$stack.peek()).value;
		
							
							
							Lista_variables_Enteras listaVar = (Lista_variables_Enteras)var;
							ScopeIF sc = scopeManager.getCurrentScope();
							SymbolTableIF ts = sc.getSymbolTable();
							


							if (ts.containsSymbol(id1.getLexema())){
								semanticErrorManager.semanticFatalError("Error. La variable:" + id1.getLexema() + " ya ha sido declarada en la linea " + id1.getLine());
							}
							else {
								//Comprobamos que exista el símbolo correspondiente
								if (ts.containsSymbol(id2.getLexema())) {
									SymbolIF simbolo = (ts.getSymbol(id2.getLexema()));
									SymbolVariable sVariable;
									listaVar.addVariable(id1.getLexema());
									//Comprobamos que el símbolo es del tipo adecuado
									if(simbolo.getType() instanceof TypeSimple){	
										//Hacemos casting según sea el tipo variable o constante. A continuación creamos el nuevo símbolo y lo introducimos a la tabla
										if (simbolo instanceof SymbolVariable) {
											
											 
											 sVariable = new SymbolVariable(sc,id1.getLexema(), scopeManager.searchType("Entero"),((SymbolVariable)simbolo).getValor() );

										}
											else {
												sVariable = new SymbolVariable(sc,id1.getLexema(), scopeManager.searchType("Entero"),((SymbolConstant)simbolo).getValor() );

											}
										
										listaVar.setValor(sVariable.getValor());
									
										ts.addSymbol(sVariable);
										ts= listaVar.actualizaValores(ts);

									    

										RESULT = listaVar;
										
										}
								
									else
										semanticErrorManager.semanticFatalError("Error. Asignación incorrecta a la variable:" + id1.getLexema() + "en la línea" + id1.getLine() );

									
							}
								else
									semanticErrorManager.semanticFatalError("Error. No existe el identificador:" + id2.getLexema() + "en la línea" + id1.getLine() );

								
							
							}
								
								
								
								
							
              CUP$parser$result = parser.getSymbolFactory().newSymbol("lista_variables_enteras",13, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-4)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 29: // lista_variables_enteras ::= lista_variables_enteras COMA IDENTIFICADOR ASIGNACION NUMERO 
            {
              Object RESULT =null;
		int varleft = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-4)).left;
		int varright = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-4)).right;
		Object var = (Object)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-4)).value;
		int idleft = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)).left;
		int idright = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)).right;
		Token id = (Token)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-2)).value;
		int valorleft = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).left;
		int valorright = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).right;
		Token valor = (Token)((java_cup.runtime.Symbol) CUP$parser$stack.peek()).value;
		
								
								//Añadimos el valor a la variable que sube y introducimos la nueva
									
									Lista_variables_Enteras listaVar = (Lista_variables_Enteras)var;
									listaVar.setValor(Integer.parseInt(valor.getLexema()));
									ScopeIF sc = scopeManager.getCurrentScope();
									SymbolTableIF ts = sc.getSymbolTable();
								    ts= listaVar.actualizaValores(ts);

							

									if (ts.containsSymbol(id.getLexema())){
										semanticErrorManager.semanticFatalError("Error. La variable:" + id.getLexema() + " ya ha sido declarada en la linea " + id.getLine());
									}
									else {
										if(TypeSimple.rangoCorrecto(Integer.parseInt(valor.getLexema()))){										
											listaVar.addVariable(id.getLexema());
											SymbolVariable sVariable = new SymbolVariable(sc,id.getLexema(), scopeManager.searchType("Entero"), Integer.parseInt(valor.getLexema()));

											ts.addSymbol(sVariable);
											RESULT = listaVar;
											}
										
										else
											semanticErrorManager.semanticFatalError("Error. El numero " + valor.getLexema() + " excede el rango permitido para las variables en la linea " + valor.getLine());

											
									};
								
								
								
              CUP$parser$result = parser.getSymbolFactory().newSymbol("lista_variables_enteras",13, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-4)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 28: // lista_variables_enteras ::= lista_variables_enteras COMA IDENTIFICADOR 
            {
              Object RESULT =null;
		int varleft = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)).left;
		int varright = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)).right;
		Object var = (Object)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-2)).value;
		int idleft = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).left;
		int idright = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).right;
		Token id = (Token)((java_cup.runtime.Symbol) CUP$parser$stack.peek()).value;
		
								 //Análogo a la versión anterior
									ScopeIF sc = scopeManager.getCurrentScope();
									SymbolTableIF ts = sc.getSymbolTable();


									if (ts.containsSymbol(id.getLexema())){
										semanticErrorManager.semanticFatalError("Error. La variable:" + id.getLexema() + " ya ha sido declarada en la linea " + id.getLine());
									}
									else {
										Lista_variables_Enteras listaVar = (Lista_variables_Enteras)var;
										listaVar.addVariable(id.getLexema());
										SymbolVariable sVariable = new SymbolVariable(sc,id.getLexema(), scopeManager.searchType("Entero"));

										ts.addSymbol(sVariable);
										RESULT = listaVar;
									}
		
              CUP$parser$result = parser.getSymbolFactory().newSymbol("lista_variables_enteras",13, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 27: // lista_variables_enteras ::= ENTERO IDENTIFICADOR ASIGNACION IDENTIFICADOR 
            {
              Object RESULT =null;
		int id1left = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)).left;
		int id1right = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)).right;
		Token id1 = (Token)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-2)).value;
		int id2left = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).left;
		int id2right = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).right;
		Token id2 = (Token)((java_cup.runtime.Symbol) CUP$parser$stack.peek()).value;
		
									ScopeIF sc = scopeManager.getCurrentScope();
									SymbolTableIF ts = sc.getSymbolTable();

									if (ts.containsSymbol(id1.getLexema())){
										semanticErrorManager.semanticFatalError("Error. La variable:" + id1.getLexema() + " ya ha sido declarada en la linea " + id1.getLine());
									}
									else {
										//Comprobamos que exista el símbolo correspondiente
										if (ts.containsSymbol(id2.getLexema())) {
											SymbolIF simbolo = (ts.getSymbol(id2.getLexema()));
											SymbolVariable sVariable;
											Lista_variables_Enteras listaVar = new Lista_variables_Enteras();											//Comprobamos que el símbolo es del tipo adecuado
											if(simbolo.getType() instanceof TypeSimple){	
												//Hacemos casting según sea el tipo variable o constante. A continuación creamos el nuevo símbolo y lo introducimos a la tabla
												
												listaVar.addVariable(id1.getLexema());
												if (simbolo instanceof SymbolVariable) {
													 sVariable = new SymbolVariable(sc,id1.getLexema(), scopeManager.searchType("Entero"),((SymbolVariable)simbolo).getValor());

												}
													else {
													 sVariable = new SymbolVariable(sc,id1.getLexema(), scopeManager.searchType("Entero"),((SymbolConstant)simbolo).getValor() );

													}
												
												listaVar.setValor(sVariable.getValor());
												ts.addSymbol(sVariable);
												RESULT = listaVar;
												
												}
										
											else
												semanticErrorManager.semanticFatalError("Error. Asignación incorrecta a la variable:" + id1.getLexema() + "en la línea" + id1.getLine() );

											
									}
										else
											semanticErrorManager.semanticFatalError("Error. No existe el identificador:" + id2.getLexema() + "en la línea" + id1.getLine() );

										
									
									}
		
              CUP$parser$result = parser.getSymbolFactory().newSymbol("lista_variables_enteras",13, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-3)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 26: // lista_variables_enteras ::= ENTERO IDENTIFICADOR ASIGNACION NUMERO 
            {
              Object RESULT =null;
		int idleft = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)).left;
		int idright = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)).right;
		Token id = (Token)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-2)).value;
		int valorleft = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).left;
		int valorright = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).right;
		Token valor = (Token)((java_cup.runtime.Symbol) CUP$parser$stack.peek()).value;
		
									ScopeIF sc = scopeManager.getCurrentScope();
									SymbolTableIF ts = sc.getSymbolTable();

									if (ts.containsSymbol(id.getLexema())){
										semanticErrorManager.semanticFatalError("Error. La variable:" + id.getLexema() + " ya ha sido declarada en la linea " + id.getLine());
									}
									else {
										if(TypeSimple.rangoCorrecto(Integer.parseInt(valor.getLexema()))){										
											Lista_variables_Enteras listaVar = new Lista_variables_Enteras();
											listaVar.addVariable(id.getLexema());
											listaVar.setValor(Integer.parseInt(valor.getLexema()));
											SymbolVariable sVariable = new SymbolVariable(sc,id.getLexema(),  scopeManager.searchType("Entero"), Integer.parseInt(valor.getLexema()));
											ts.addSymbol(sVariable);
										
											RESULT = listaVar;}
										
										else
											semanticErrorManager.semanticFatalError("Error. El numero " + valor.getLexema() + " excede el rango permitido para las variables en la linea " + valor.getLine());

											
									}
		
              CUP$parser$result = parser.getSymbolFactory().newSymbol("lista_variables_enteras",13, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-3)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 25: // lista_variables_enteras ::= ENTERO IDENTIFICADOR 
            {
              Object RESULT =null;
		int idleft = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).left;
		int idright = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).right;
		Token id = (Token)((java_cup.runtime.Symbol) CUP$parser$stack.peek()).value;
		
									ScopeIF sc = scopeManager.getCurrentScope();
									SymbolTableIF ts = sc.getSymbolTable();

									if (ts.containsSymbol(id.getLexema())){
										semanticErrorManager.semanticFatalError("Error. La variable:" + id.getLexema() + " ya ha sido declarada en la linea " + id.getLine());
									}
									else {
										Lista_variables_Enteras listaVar = new Lista_variables_Enteras();
										listaVar.addVariable(id.getLexema());
										SymbolVariable sVariable = new SymbolVariable(sc,id.getLexema(), scopeManager.searchType("Entero"));
										ts.addSymbol(sVariable);
										RESULT = listaVar;
									}
		
              CUP$parser$result = parser.getSymbolFactory().newSymbol("lista_variables_enteras",13, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 24: // declar_variable ::= lista_variables_matriz PUNTOYCOMA 
            {
              Object RESULT =null;

              CUP$parser$result = parser.getSymbolFactory().newSymbol("declar_variable",10, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 23: // declar_variable ::= lista_variables_enteras PUNTOYCOMA 
            {
              Object RESULT =null;
		
	
	ScopeIF sc = scopeManager.getCurrentScope();
SymbolTableIF ts = sc.getSymbolTable();

	
              CUP$parser$result = parser.getSymbolFactory().newSymbol("declar_variable",10, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 22: // rango_matriz ::= CORIZQ expresion CORDER 
            {
              Object RESULT =null;
		int exleft = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)).left;
		int exright = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)).right;
		Object ex = (Object)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-1)).value;
		int cleft = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).left;
		int cright = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).right;
		Token c = (Token)((java_cup.runtime.Symbol) CUP$parser$stack.peek()).value;
		
	
		RESULT =  ((Expresion)ex).getValor();

	
              CUP$parser$result = parser.getSymbolFactory().newSymbol("rango_matriz",12, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 21: // rango_matriz_declar ::= CORIZQ IDENTIFICADOR NT$6 CORDER 
            {
              Object RESULT =null;
              // propagate RESULT from NT$6
                RESULT = (Object) ((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-1)).value;
		int rleft = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)).left;
		int rright = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)).right;
		Token r = (Token)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-2)).value;

              CUP$parser$result = parser.getSymbolFactory().newSymbol("rango_matriz_declar",11, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-3)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 20: // NT$6 ::= 
            {
              Object RESULT =null;
		int rleft = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).left;
		int rright = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).right;
		Token r = (Token)((java_cup.runtime.Symbol) CUP$parser$stack.peek()).value;

						
					ScopeIF sc = scopeManager.getCurrentScope();
					SymbolTableIF ts = sc.getSymbolTable();
					
					//Comprobamos que en la tabla de símbolos aparece el simbolo correspondiente. En caso afirmativo recuperamos su valor y comprobamos que no excede el rango.
					if (ts.containsSymbol(r.getLexema())) {
						SymbolIF c = ts.getSymbol(r.getLexema());
						if (TypeSimple.rangoPositivo(((SymbolConstant)c).getValor())) {
							RESULT = ((SymbolConstant)c).getValor();
						}
						else
							semanticErrorManager.semanticFatalError("Error. El numero " + r.getLexema() + " excede el rango permitido en  la matriz en la linea " + r.getLine());
					}
					else 	semanticErrorManager.semanticFatalError("Error. No existe el identificador " + r.getLexema() + "  en la linea " + r.getLine());
						
					
              CUP$parser$result = parser.getSymbolFactory().newSymbol("NT$6",46, ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 19: // rango_matriz_declar ::= CORIZQ NUMERO NT$5 CORDER 
            {
              Object RESULT =null;
              // propagate RESULT from NT$5
                RESULT = (Object) ((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-1)).value;
		int rleft = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)).left;
		int rright = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)).right;
		Token r = (Token)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-2)).value;

              CUP$parser$result = parser.getSymbolFactory().newSymbol("rango_matriz_declar",11, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-3)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 18: // NT$5 ::= 
            {
              Object RESULT =null;
		int rleft = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).left;
		int rright = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).right;
		Token r = (Token)((java_cup.runtime.Symbol) CUP$parser$stack.peek()).value;

						if (TypeSimple.rangoPositivo(Integer.parseInt(r.getLexema()))){
							RESULT =Integer.parseInt(r.getLexema());
						}
						else
							semanticErrorManager.semanticFatalError("Error. El numero " + r.getLexema() + " excede el rango permitido en  la matriz en la linea " + r.getLine());
							
						
					
              CUP$parser$result = parser.getSymbolFactory().newSymbol("NT$5",45, ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 17: // declar_tipo ::= ENTERO IDENTIFICADOR rango_matriz_declar rango_matriz_declar NT$4 PUNTOYCOMA 
            {
              Object RESULT =null;
              // propagate RESULT from NT$4
                RESULT = (Object) ((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-1)).value;
		int idleft = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-4)).left;
		int idright = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-4)).right;
		Token id = (Token)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-4)).value;
		int r1left = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-3)).left;
		int r1right = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-3)).right;
		Object r1 = (Object)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-3)).value;
		int r2left = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)).left;
		int r2right = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)).right;
		Object r2 = (Object)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-2)).value;

              CUP$parser$result = parser.getSymbolFactory().newSymbol("declar_tipo",8, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-5)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 16: // NT$4 ::= 
            {
              Object RESULT =null;
		int idleft = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)).left;
		int idright = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)).right;
		Token id = (Token)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-2)).value;
		int r1left = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)).left;
		int r1right = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)).right;
		Object r1 = (Object)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-1)).value;
		int r2left = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).left;
		int r2right = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).right;
		Object r2 = (Object)((java_cup.runtime.Symbol) CUP$parser$stack.peek()).value;

					ScopeIF sc = scopeManager.getCurrentScope();
					TypeTableIF tt = sc.getTypeTable();
					if (tt.containsType(id.getLexema()))
						semanticErrorManager.semanticFatalError("Error. El tipo:" + id.getLexema() + " ya ha sido declarado con anterioridad en la linea " + id.getLine());
					else {
						TypeArray matriz = new TypeArray(sc,id.getLexema(), (int)r1,(int)r2);
						tt.addType(id.getLexema(),matriz);
						Declar_tipo tipo = new Declar_tipo(id.getLexema(), (int)r1, (int)r2);
						RESULT =  tipo;
						
					

					}
	
	
	
              CUP$parser$result = parser.getSymbolFactory().newSymbol("NT$4",44, ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 15: // declar_const ::= DEFINE IDENTIFICADOR NUMERO NT$3 PUNTOYCOMA 
            {
              Object RESULT =null;
              // propagate RESULT from NT$3
                RESULT = (Object) ((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-1)).value;
		int idleft = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-3)).left;
		int idright = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-3)).right;
		Token id = (Token)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-3)).value;
		int valorleft = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)).left;
		int valorright = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)).right;
		Token valor = (Token)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-2)).value;

              CUP$parser$result = parser.getSymbolFactory().newSymbol("declar_const",6, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-4)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 14: // NT$3 ::= 
            {
              Object RESULT =null;
		int idleft = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)).left;
		int idright = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)).right;
		Token id = (Token)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-1)).value;
		int valorleft = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).left;
		int valorright = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).right;
		Token valor = (Token)((java_cup.runtime.Symbol) CUP$parser$stack.peek()).value;

				ScopeIF sc = scopeManager.getCurrentScope();
				SymbolTableIF ts = sc.getSymbolTable();
				
				if (ts.containsSymbol(id.getLexema())){
					semanticErrorManager.semanticFatalError("La constante:" + id.getLexema() + " ya ha sido declarada en la linea " + id.getLine());
				}
				else {
					if (TypeSimple.rangoCorrecto(Integer.parseInt(valor.getLexema()))) {
						SymbolConstant sConstant = new SymbolConstant(sc,id.getLexema(), scopeManager.searchType("Entero"), Integer.parseInt(valor.getLexema()));
						Declar_const c = new Declar_const(Integer.parseInt(valor.getLexema()),"Constante");
						ts.addSymbol(sConstant);
						RESULT = c;
					}
					else
						semanticErrorManager.semanticFatalError("Error. La constante:" + id.getLexema() + " tiene un valor fuera de rango en la linea" + id.getLine());
					
					
				}
				
              CUP$parser$result = parser.getSymbolFactory().newSymbol("NT$3",43, ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 13: // declar_funciones_glo ::= declar_main 
            {
              Object RESULT =null;

              CUP$parser$result = parser.getSymbolFactory().newSymbol("declar_funciones_glo",4, ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 12: // declar_funciones_glo ::= declar_funcion declar_funciones_glo 
            {
              Object RESULT =null;

              CUP$parser$result = parser.getSymbolFactory().newSymbol("declar_funciones_glo",4, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 11: // declar_variables_glo ::= declar_funciones_glo 
            {
              Object RESULT =null;

              CUP$parser$result = parser.getSymbolFactory().newSymbol("declar_variables_glo",3, ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 10: // declar_variables_glo ::= declar_variable declar_variables_glo 
            {
              Object RESULT =null;

              CUP$parser$result = parser.getSymbolFactory().newSymbol("declar_variables_glo",3, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 9: // declar_tipos_glo ::= declar_variables_glo 
            {
              Object RESULT =null;

              CUP$parser$result = parser.getSymbolFactory().newSymbol("declar_tipos_glo",2, ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 8: // declar_tipos_glo ::= declar_tipo declar_tipos_glo 
            {
              Object RESULT =null;

              CUP$parser$result = parser.getSymbolFactory().newSymbol("declar_tipos_glo",2, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 7: // declar_consts ::= declar_tipos_glo 
            {
              Object RESULT =null;

              CUP$parser$result = parser.getSymbolFactory().newSymbol("declar_consts",1, ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 6: // declar_consts ::= declar_const NT$2 declar_consts 
            {
              Object RESULT =null;
              // propagate RESULT from NT$2
                RESULT = (Object) ((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-1)).value;
		int cleft = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)).left;
		int cright = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)).right;
		Object c = (Object)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-2)).value;

              CUP$parser$result = parser.getSymbolFactory().newSymbol("declar_consts",1, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 5: // NT$2 ::= 
            {
              Object RESULT =null;
		int cleft = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).left;
		int cright = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).right;
		Object c = (Object)((java_cup.runtime.Symbol) CUP$parser$stack.peek()).value;

	
			RESULT = c;
			
              CUP$parser$result = parser.getSymbolFactory().newSymbol("NT$2",42, ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 4: // axiom ::= NT$1 declar_consts 
            {
              Axiom RESULT =null;
              // propagate RESULT from NT$1
                RESULT = (Axiom) ((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-1)).value;

              CUP$parser$result = parser.getSymbolFactory().newSymbol("axiom",35, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 3: // NT$1 ::= 
            {
              Axiom RESULT =null;

	
			//Abrimos el ámbito global, creamos los tipos y los añadimos a la tabla de símbolos
			ScopeIF ambito = scopeManager.openScope("Global");
			
			System.out.println("Tras abrir ambito principal "+ ambito);
			TypeTableIF tt = ambito.getTypeTable();
			TypeSimple entero = new TypeSimple(ambito,"Entero");
			tt.addType("Entero",entero);
			
			
		
			
			
              CUP$parser$result = parser.getSymbolFactory().newSymbol("NT$1",41, ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 2: // program ::= NT$0 axiom 
            {
              Object RESULT =null;
              // propagate RESULT from NT$0
                RESULT = (Object) ((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-1)).value;
		int axleft = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).left;
		int axright = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).right;
		Axiom ax = (Axiom)((java_cup.runtime.Symbol) CUP$parser$stack.peek()).value;
		 
  		// No modificar esta estructura, aunque se pueden añadir más acciones semánticas
  		
  		//List intermediateCode = ax.getIntermediateCode ();
  		//finalCodeFactory.create (intermediateCode);
  		// En caso de no comentarse las sentencias anteriores puede generar una excepcion
  		// en las llamadas a cupTest si el compilador no está completo. Esto es debido a que 
  		// aún no se tendrá implementada la generación de código intermedio ni final.
  		// Para la entrega final deberán descomentarse y usarse.
  		
  		syntaxErrorManager.syntaxInfo ("Parsing process ended.");
  
              CUP$parser$result = parser.getSymbolFactory().newSymbol("program",0, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 1: // NT$0 ::= 
            {
              Object RESULT =null;
 syntaxErrorManager.syntaxInfo ("Starting parsing..."); 
	
	
  
              CUP$parser$result = parser.getSymbolFactory().newSymbol("NT$0",40, ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 0: // $START ::= program EOF 
            {
              Object RESULT =null;
		int start_valleft = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)).left;
		int start_valright = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)).right;
		Object start_val = (Object)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-1)).value;
		RESULT = start_val;
              CUP$parser$result = parser.getSymbolFactory().newSymbol("$START",0, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          /* ACCEPT */
          CUP$parser$parser.done_parsing();
          return CUP$parser$result;

          /* . . . . . .*/
          default:
            throw new Exception(
               "Invalid action number found in internal parse table");

        }
    }
}

