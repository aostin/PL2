
//----------------------------------------------------
// The following code was generated by CUP v0.11a beta 20060608
// Sun Apr 29 18:13:23 CEST 2018
//----------------------------------------------------

package compiler.syntax;

import java_cup.runtime.Symbol;
import java.util.*;
import es.uned.lsi.compiler.lexical.*;
import es.uned.lsi.compiler.code.*;
import es.uned.lsi.compiler.intermediate.*;
import es.uned.lsi.compiler.semantic.*;
import es.uned.lsi.compiler.semantic.symbol.*;
import es.uned.lsi.compiler.semantic.type.*;
import es.uned.lsi.compiler.syntax.*;
import compiler.CompilerContext;
import compiler.lexical.*;
import compiler.syntax.nonTerminal.*;
import compiler.semantic.*;
import compiler.semantic.symbol.*;
import compiler.semantic.type.*;
import compiler.intermediate.*;
import compiler.code.*;

/** CUP v0.11a beta 20060608 generated parser.
  * @version Sun Apr 29 18:13:23 CEST 2018
  */
public class parser extends java_cup.runtime.lr_parser {

  /** Default constructor. */
  public parser() {super();}

  /** Constructor which sets the default scanner. */
  public parser(java_cup.runtime.Scanner s) {super(s);}

  /** Constructor which sets the default scanner. */
  public parser(java_cup.runtime.Scanner s, java_cup.runtime.SymbolFactory sf) {super(s,sf);}

  /** Production table. */
  protected static final short _production_table[][] = 
    unpackFromStrings(new String[] {
    "\000\145\000\002\002\004\000\002\052\002\000\002\002" +
    "\004\000\002\053\002\000\002\045\004\000\002\054\002" +
    "\000\002\003\005\000\002\003\003\000\002\004\004\000" +
    "\002\004\003\000\002\005\004\000\002\005\003\000\002" +
    "\006\004\000\002\006\003\000\002\055\002\000\002\010" +
    "\007\000\002\056\002\000\002\012\010\000\002\057\002" +
    "\000\002\015\006\000\002\060\002\000\002\015\006\000" +
    "\002\016\005\000\002\014\004\000\002\014\004\000\002" +
    "\017\004\000\002\017\006\000\002\017\006\000\002\017" +
    "\005\000\002\017\007\000\002\017\007\000\002\020\004" +
    "\000\002\020\005\000\002\061\002\000\002\021\007\000" +
    "\002\062\002\000\002\021\007\000\002\007\007\000\002" +
    "\023\004\000\002\063\002\000\002\023\006\000\002\024" +
    "\005\000\002\024\007\000\002\022\003\000\002\022\003" +
    "\000\002\064\002\000\002\035\005\000\002\065\002\000" +
    "\002\066\002\000\002\035\007\000\002\036\003\000\002" +
    "\011\004\000\002\011\003\000\002\011\003\000\002\013" +
    "\004\000\002\013\003\000\002\013\003\000\002\037\003" +
    "\000\002\037\004\000\002\037\003\000\002\037\004\000" +
    "\002\040\003\000\002\040\003\000\002\040\003\000\002" +
    "\040\003\000\002\040\004\000\002\040\004\000\002\040" +
    "\003\000\002\026\005\000\002\026\007\000\002\027\003" +
    "\000\002\027\003\000\002\027\005\000\002\027\003\000" +
    "\002\027\005\000\002\027\005\000\002\027\005\000\002" +
    "\027\005\000\002\027\005\000\002\025\003\000\002\025" +
    "\003\000\002\030\004\000\002\031\004\000\002\031\005" +
    "\000\002\032\003\000\002\032\005\000\002\033\003\000" +
    "\002\033\005\000\002\041\007\000\002\041\007\000\002" +
    "\041\011\000\002\041\011\000\002\041\011\000\002\041" +
    "\011\000\002\042\007\000\002\042\007\000\002\043\007" +
    "\000\002\043\006\000\002\044\007\000\002\034\005\000" +
    "\002\034\004" });

  /** Access to production table. */
  public short[][] production_table() {return _production_table;}

  /** Parse-action table. */
  protected static final short[][] _action_table = 
    unpackFromStrings(new String[] {
    "\000\300\000\012\004\000\005\000\010\000\015\000\001" +
    "\002\000\004\002\302\001\002\000\012\004\ufffe\005\ufffe" +
    "\010\ufffe\015\ufffe\001\002\000\012\004\025\005\010\010" +
    "\012\015\014\001\002\000\004\002\uffff\001\002\000\004" +
    "\004\276\001\002\000\012\004\ufffc\005\ufffc\010\ufffc\015" +
    "\ufffc\001\002\000\004\004\273\001\002\000\004\002\ufff8" +
    "\001\002\000\006\004\263\011\264\001\002\000\006\027" +
    "\260\030\261\001\002\000\006\027\252\030\253\001\002" +
    "\000\004\002\ufff4\001\002\000\004\002\ufffa\001\002\000" +
    "\006\010\247\015\014\001\002\000\004\002\ufff6\001\002" +
    "\000\004\002\ufffd\001\002\000\010\004\025\010\031\015" +
    "\014\001\002\000\004\004\030\001\002\000\010\004\025" +
    "\010\012\015\014\001\002\000\004\002\ufff9\001\002\000" +
    "\006\027\uffe2\030\uffe2\001\002\000\004\004\033\001\002" +
    "\000\004\002\ufff7\001\002\000\012\021\uffe0\027\uffe8\030" +
    "\uffe8\035\034\001\002\000\006\004\246\020\245\001\002" +
    "\000\004\021\036\001\002\000\010\004\231\010\234\022" +
    "\230\001\002\000\004\025\041\001\002\000\006\010\uffdf" +
    "\015\uffdf\001\002\000\024\004\uffd2\006\uffd2\010\uffd2\012" +
    "\uffd2\013\uffd2\014\uffd2\016\uffd2\025\uffd2\026\uffd4\001\002" +
    "\000\004\026\227\001\002\000\022\004\067\006\060\010" +
    "\070\012\063\013\057\014\055\016\052\025\041\001\002" +
    "\000\024\004\uffc2\006\uffc2\007\uffc2\012\uffc2\013\uffc2\014" +
    "\uffc2\016\uffc2\025\uffc2\026\uffc2\001\002\000\004\026\uffcc" +
    "\001\002\000\024\004\uffbe\006\uffbe\007\uffbe\012\uffbe\013" +
    "\uffbe\014\uffbe\016\uffbe\025\uffbe\026\uffbe\001\002\000\024" +
    "\004\067\006\060\010\070\012\063\013\057\014\055\016" +
    "\052\025\041\026\uffcd\001\002\000\004\026\uffc9\001\002" +
    "\000\024\004\uffc1\006\uffc1\007\uffc1\012\uffc1\013\uffc1\014" +
    "\uffc1\016\uffc1\025\uffc1\026\uffc1\001\002\000\004\021\221" +
    "\001\002\000\022\004\164\006\060\012\063\013\057\014" +
    "\055\016\052\025\041\026\uffc8\001\002\000\024\004\uffc4" +
    "\006\uffc4\007\uffc4\012\uffc4\013\uffc4\014\uffc4\016\uffc4\025" +
    "\uffc4\026\uffc4\001\002\000\012\004\150\020\131\021\132" +
    "\030\215\001\002\000\004\026\uffcf\001\002\000\004\021" +
    "\207\001\002\000\004\021\174\001\002\000\004\026\uffd1" +
    "\001\002\000\004\030\171\001\002\000\004\021\165\001" +
    "\002\000\022\004\164\006\060\012\063\013\057\014\055" +
    "\016\052\025\041\026\uffc6\001\002\000\004\030\162\001" +
    "\002\000\024\004\uffc3\006\uffc3\007\uffc3\012\uffc3\013\uffc3" +
    "\014\uffc3\016\uffc3\025\uffc3\026\uffc3\001\002\000\012\004" +
    "\030\021\114\023\111\035\112\001\002\000\004\004\075" +
    "\001\002\000\024\004\067\006\060\010\073\012\063\013" +
    "\057\014\055\016\052\025\041\026\uffca\001\002\000\004" +
    "\026\uffcb\001\002\000\004\004\074\001\002\000\010\027" +
    "\uffe8\030\uffe8\035\034\001\002\000\012\023\076\027\uffe8" +
    "\030\uffe8\035\034\001\002\000\006\004\104\020\103\001" +
    "\002\000\004\023\076\001\002\000\004\030\ufff1\001\002" +
    "\000\004\030\102\001\002\000\026\004\ufff0\006\ufff0\010" +
    "\ufff0\012\ufff0\013\ufff0\014\ufff0\015\ufff0\016\ufff0\025\ufff0" +
    "\026\ufff0\001\002\000\004\024\uffef\001\002\000\004\024" +
    "\uffed\001\002\000\004\024\106\001\002\000\006\023\uffec" +
    "\030\uffec\001\002\000\004\024\110\001\002\000\006\023" +
    "\uffee\030\uffee\001\002\000\010\004\150\020\131\021\132" +
    "\001\002\000\010\004\134\020\131\021\132\001\002\000" +
    "\004\023\111\001\002\000\006\004\120\022\116\001\002" +
    "\000\020\022\uffb0\024\uffb0\030\uffb0\031\uffb0\032\uffb0\033" +
    "\uffb0\034\uffb0\001\002\000\020\022\uffaf\024\uffaf\030\uffaf" +
    "\031\uffaf\032\uffaf\033\uffaf\034\uffaf\001\002\000\006\022" +
    "\125\027\124\001\002\000\010\022\uffab\023\111\027\uffab" +
    "\001\002\000\006\022\uffad\027\uffad\001\002\000\004\023" +
    "\111\001\002\000\006\022\uffaa\027\uffaa\001\002\000\004" +
    "\004\120\001\002\000\020\022\uffae\024\uffae\030\uffae\031" +
    "\uffae\032\uffae\033\uffae\034\uffae\001\002\000\006\022\uffac" +
    "\027\uffac\001\002\000\004\035\130\001\002\000\010\004" +
    "\134\020\131\021\132\001\002\000\020\022\uffbb\024\uffbb" +
    "\030\uffbb\031\uffbb\032\uffbb\033\uffbb\034\uffbb\001\002\000" +
    "\010\004\150\020\131\021\132\001\002\000\020\022\uffb8" +
    "\024\uffb8\030\uffb8\031\uffb8\032\uffb8\033\uffb8\034\uffb8\001" +
    "\002\000\024\021\114\022\uffba\023\111\024\uffba\030\uffba" +
    "\031\uffba\032\uffba\033\uffba\034\uffba\001\002\000\020\022" +
    "\uffbc\024\uffbc\030\uffbc\031\136\032\141\033\140\034\137" +
    "\001\002\000\010\004\134\020\131\021\132\001\002\000" +
    "\010\004\134\020\131\021\132\001\002\000\010\004\134" +
    "\020\131\021\132\001\002\000\010\004\134\020\131\021" +
    "\132\001\002\000\020\022\uffb6\024\uffb6\030\uffb6\031\136" +
    "\032\uffb6\033\uffb6\034\uffb6\001\002\000\020\022\uffb5\024" +
    "\uffb5\030\uffb5\031\136\032\141\033\uffb5\034\uffb5\001\002" +
    "\000\020\022\uffb4\024\uffb4\030\uffb4\031\136\032\141\033" +
    "\140\034\uffb4\001\002\000\020\022\uffb7\024\uffb7\030\uffb7" +
    "\031\uffb7\032\uffb7\033\uffb7\034\uffb7\001\002\000\004\023" +
    "\111\001\002\000\020\022\uffb9\024\uffb9\030\uffb9\031\uffb9" +
    "\032\uffb9\033\uffb9\034\uffb9\001\002\000\026\021\114\022" +
    "\uffba\023\111\024\uffba\030\uffba\031\uffba\032\uffba\033\uffba" +
    "\034\uffba\035\112\001\002\000\020\022\uffb2\024\uffb2\030" +
    "\uffb2\031\136\032\141\033\140\034\137\001\002\000\004" +
    "\022\154\001\002\000\010\022\uffb1\024\uffb1\030\uffb1\001" +
    "\002\000\020\022\uffb3\024\uffb3\030\uffb3\031\uffb3\032\uffb3" +
    "\033\uffb3\034\uffb3\001\002\000\004\023\111\001\002\000" +
    "\022\022\uffb9\024\uffb9\030\uffb9\031\uffb9\032\uffb9\033\uffb9" +
    "\034\uffb9\035\130\001\002\000\020\022\uffbd\024\uffbd\030" +
    "\uffbd\031\136\032\141\033\140\034\137\001\002\000\004" +
    "\024\161\001\002\000\026\022\uffeb\023\uffeb\024\uffeb\027" +
    "\uffeb\030\uffeb\031\uffeb\032\uffeb\033\uffeb\034\uffeb\035\uffeb" +
    "\001\002\000\024\004\uffbf\006\uffbf\007\uffbf\012\uffbf\013" +
    "\uffbf\014\uffbf\016\uffbf\025\uffbf\026\uffbf\001\002\000\004" +
    "\026\uffc5\001\002\000\010\021\114\023\111\035\112\001" +
    "\002\000\004\017\166\001\002\000\004\022\167\001\002" +
    "\000\004\030\170\001\002\000\024\004\uff9f\006\uff9f\007" +
    "\uff9f\012\uff9f\013\uff9f\014\uff9f\016\uff9f\025\uff9f\026\uff9f" +
    "\001\002\000\024\004\uffc0\006\uffc0\007\uffc0\012\uffc0\013" +
    "\uffc0\014\uffc0\016\uffc0\025\uffc0\026\uffc0\001\002\000\004" +
    "\026\173\001\002\000\032\002\uffd0\004\uffd0\006\uffd0\007" +
    "\uffd0\010\uffd0\012\uffd0\013\uffd0\014\uffd0\015\uffd0\016\uffd0" +
    "\025\uffd0\026\uffd0\001\002\000\010\004\150\020\131\021" +
    "\132\001\002\000\004\022\176\001\002\000\020\004\164" +
    "\006\060\012\063\013\057\014\055\016\052\025\041\001" +
    "\002\000\024\004\uffa9\006\uffa9\007\204\012\uffa9\013\uffa9" +
    "\014\uffa9\016\uffa9\025\uffa9\026\uffa9\001\002\000\024\004" +
    "\uffa8\006\uffa8\007\201\012\uffa8\013\uffa8\014\uffa8\016\uffa8" +
    "\025\uffa8\026\uffa8\001\002\000\020\004\164\006\060\012" +
    "\063\013\057\014\055\016\052\025\041\001\002\000\024" +
    "\004\uffa5\006\uffa5\007\uffa5\012\uffa5\013\uffa5\014\uffa5\016" +
    "\uffa5\025\uffa5\026\uffa5\001\002\000\024\004\uffa4\006\uffa4" +
    "\007\uffa4\012\uffa4\013\uffa4\014\uffa4\016\uffa4\025\uffa4\026" +
    "\uffa4\001\002\000\020\004\164\006\060\012\063\013\057" +
    "\014\055\016\052\025\041\001\002\000\024\004\uffa7\006" +
    "\uffa7\007\uffa7\012\uffa7\013\uffa7\014\uffa7\016\uffa7\025\uffa7" +
    "\026\uffa7\001\002\000\024\004\uffa6\006\uffa6\007\uffa6\012" +
    "\uffa6\013\uffa6\014\uffa6\016\uffa6\025\uffa6\026\uffa6\001\002" +
    "\000\012\004\150\020\131\021\132\022\210\001\002\000" +
    "\004\030\214\001\002\000\004\022\212\001\002\000\004" +
    "\030\213\001\002\000\024\004\uffa1\006\uffa1\007\uffa1\012" +
    "\uffa1\013\uffa1\014\uffa1\016\uffa1\025\uffa1\026\uffa1\001\002" +
    "\000\024\004\uffa0\006\uffa0\007\uffa0\012\uffa0\013\uffa0\014" +
    "\uffa0\016\uffa0\025\uffa0\026\uffa0\001\002\000\024\004\uff9d" +
    "\006\uff9d\007\uff9d\012\uff9d\013\uff9d\014\uff9d\016\uff9d\025" +
    "\uff9d\026\uff9d\001\002\000\004\030\217\001\002\000\024" +
    "\004\uff9e\006\uff9e\007\uff9e\012\uff9e\013\uff9e\014\uff9e\016" +
    "\uff9e\025\uff9e\026\uff9e\001\002\000\004\026\uffc7\001\002" +
    "\000\010\004\150\020\131\021\132\001\002\000\004\022" +
    "\223\001\002\000\020\004\164\006\060\012\063\013\057" +
    "\014\055\016\052\025\041\001\002\000\024\004\uffa3\006" +
    "\uffa3\007\uffa3\012\uffa3\013\uffa3\014\uffa3\016\uffa3\025\uffa3" +
    "\026\uffa3\001\002\000\024\004\uffa2\006\uffa2\007\uffa2\012" +
    "\uffa2\013\uffa2\014\uffa2\016\uffa2\025\uffa2\026\uffa2\001\002" +
    "\000\004\026\uffce\001\002\000\032\002\uffd3\004\uffd3\006" +
    "\uffd3\007\uffd3\010\uffd3\012\uffd3\013\uffd3\014\uffd3\015\uffd3" +
    "\016\uffd3\025\uffd3\026\uffd3\001\002\000\004\025\uffdb\001" +
    "\002\000\004\036\uffd5\001\002\000\006\022\uffda\027\237" +
    "\001\002\000\004\036\235\001\002\000\004\036\uffd6\001" +
    "\002\000\004\004\236\001\002\000\006\022\uffd8\027\uffd8" +
    "\001\002\000\006\004\231\010\234\001\002\000\004\022" +
    "\241\001\002\000\004\025\uffd9\001\002\000\004\036\243" +
    "\001\002\000\004\004\244\001\002\000\006\022\uffd7\027" +
    "\uffd7\001\002\000\006\027\uffe7\030\uffe7\001\002\000\006" +
    "\027\uffe6\030\uffe6\001\002\000\004\004\251\001\002\000" +
    "\004\002\ufff5\001\002\000\004\021\uffe0\001\002\000\004" +
    "\004\254\001\002\000\026\004\uffea\006\uffea\010\uffea\012" +
    "\uffea\013\uffea\014\uffea\015\uffea\016\uffea\025\uffea\026\uffea" +
    "\001\002\000\010\027\uffe5\030\uffe5\035\255\001\002\000" +
    "\006\004\257\020\256\001\002\000\006\027\uffe4\030\uffe4" +
    "\001\002\000\006\027\uffe3\030\uffe3\001\002\000\004\004" +
    "\262\001\002\000\026\004\uffe9\006\uffe9\010\uffe9\012\uffe9" +
    "\013\uffe9\014\uffe9\015\uffe9\016\uffe9\025\uffe9\026\uffe9\001" +
    "\002\000\006\027\uffe1\030\uffe1\001\002\000\004\021\uffde" +
    "\001\002\000\004\021\265\001\002\000\004\022\266\001" +
    "\002\000\004\025\041\001\002\000\004\002\uffdc\001\002" +
    "\000\004\021\036\001\002\000\004\025\041\001\002\000" +
    "\006\010\uffdd\015\uffdd\001\002\000\014\021\uffe0\023\076" +
    "\027\uffe8\030\uffe8\035\034\001\002\000\012\004\025\005" +
    "\010\010\012\015\014\001\002\000\004\002\ufffb\001\002" +
    "\000\004\020\277\001\002\000\004\030\ufff3\001\002\000" +
    "\004\030\301\001\002\000\012\004\ufff2\005\ufff2\010\ufff2" +
    "\015\ufff2\001\002\000\004\002\001\001\002" });

  /** Access to parse-action table. */
  public short[][] action_table() {return _action_table;}

  /** <code>reduce_goto</code> table. */
  protected static final short[][] _reduce_table = 
    unpackFromStrings(new String[] {
    "\000\300\000\006\002\003\052\004\001\001\000\002\001" +
    "\001\000\006\045\006\053\005\001\001\000\030\003\022" +
    "\004\017\005\012\006\021\007\016\010\010\012\025\014" +
    "\023\017\015\020\014\021\020\001\001\000\002\001\001" +
    "\000\002\001\001\000\004\054\273\001\001\000\002\001" +
    "\001\000\002\001\001\000\002\001\001\000\002\001\001" +
    "\000\002\001\001\000\002\001\001\000\002\001\001\000" +
    "\010\006\247\007\016\021\020\001\001\000\002\001\001" +
    "\000\002\001\001\000\020\005\031\006\021\007\016\014" +
    "\023\017\015\020\014\021\020\001\001\000\002\001\001" +
    "\000\024\004\026\005\012\006\021\007\016\012\025\014" +
    "\023\017\015\020\014\021\020\001\001\000\002\001\001" +
    "\000\002\001\001\000\002\001\001\000\002\001\001\000" +
    "\004\061\034\001\001\000\002\001\001\000\004\023\036" +
    "\001\001\000\006\022\232\024\231\001\001\000\004\035" +
    "\037\001\001\000\002\001\001\000\006\064\041\065\042" +
    "\001\001\000\002\001\001\000\044\011\055\012\046\013" +
    "\044\014\070\017\015\020\014\026\061\030\064\034\045" +
    "\035\052\036\060\037\047\040\063\041\053\042\065\043" +
    "\043\044\050\001\001\000\002\001\001\000\002\001\001" +
    "\000\002\001\001\000\042\011\225\012\046\013\044\014" +
    "\070\017\015\020\014\026\061\030\064\034\045\035\052" +
    "\037\047\040\063\041\053\042\065\043\043\044\050\001" +
    "\001\000\002\001\001\000\002\001\001\000\002\001\001" +
    "\000\026\026\061\030\064\034\045\035\052\037\217\040" +
    "\063\041\053\042\065\043\043\044\050\001\001\000\002" +
    "\001\001\000\012\025\215\026\152\027\150\030\132\001" +
    "\001\000\002\001\001\000\002\001\001\000\002\001\001" +
    "\000\004\066\171\001\001\000\002\001\001\000\002\001" +
    "\001\000\026\026\061\030\064\034\045\035\052\037\162" +
    "\040\063\041\053\042\065\043\043\044\050\001\001\000" +
    "\002\001\001\000\002\001\001\000\006\016\112\031\114" +
    "\001\001\000\002\001\001\000\036\013\071\014\070\017" +
    "\015\020\014\026\061\030\064\034\045\035\052\037\047" +
    "\040\063\041\053\042\065\043\043\044\050\001\001\000" +
    "\002\001\001\000\002\001\001\000\002\001\001\000\004" +
    "\015\076\001\001\000\002\001\001\000\004\015\077\001" +
    "\001\000\004\056\100\001\001\000\002\001\001\000\002" +
    "\001\001\000\004\057\106\001\001\000\004\060\104\001" +
    "\001\000\002\001\001\000\002\001\001\000\002\001\001" +
    "\000\002\001\001\000\012\025\157\026\152\027\150\030" +
    "\132\001\001\000\006\027\156\030\132\001\001\000\004" +
    "\016\126\001\001\000\006\032\116\033\120\001\001\000" +
    "\002\001\001\000\002\001\001\000\002\001\001\000\004" +
    "\016\121\001\001\000\002\001\001\000\004\016\122\001" +
    "\001\000\002\001\001\000\004\033\125\001\001\000\002" +
    "\001\001\000\002\001\001\000\002\001\001\000\006\027" +
    "\134\030\132\001\001\000\002\001\001\000\012\025\151" +
    "\026\152\027\150\030\132\001\001\000\002\001\001\000" +
    "\006\016\145\031\114\001\001\000\002\001\001\000\006" +
    "\027\144\030\132\001\001\000\006\027\143\030\132\001" +
    "\001\000\006\027\142\030\132\001\001\000\006\027\141" +
    "\030\132\001\001\000\002\001\001\000\002\001\001\000" +
    "\002\001\001\000\002\001\001\000\004\016\146\001\001" +
    "\000\002\001\001\000\006\016\154\031\114\001\001\000" +
    "\002\001\001\000\002\001\001\000\002\001\001\000\002" +
    "\001\001\000\004\016\155\001\001\000\002\001\001\000" +
    "\002\001\001\000\002\001\001\000\002\001\001\000\002" +
    "\001\001\000\002\001\001\000\006\016\112\031\114\001" +
    "\001\000\002\001\001\000\002\001\001\000\002\001\001" +
    "\000\002\001\001\000\002\001\001\000\002\001\001\000" +
    "\002\001\001\000\012\025\174\026\152\027\150\030\132" +
    "\001\001\000\002\001\001\000\024\026\061\030\064\034" +
    "\045\035\177\040\176\041\053\042\065\043\043\044\050" +
    "\001\001\000\002\001\001\000\002\001\001\000\024\026" +
    "\061\030\064\034\045\035\202\040\201\041\053\042\065" +
    "\043\043\044\050\001\001\000\002\001\001\000\002\001" +
    "\001\000\024\026\061\030\064\034\045\035\205\040\204" +
    "\041\053\042\065\043\043\044\050\001\001\000\002\001" +
    "\001\000\002\001\001\000\012\025\210\026\152\027\150" +
    "\030\132\001\001\000\002\001\001\000\002\001\001\000" +
    "\002\001\001\000\002\001\001\000\002\001\001\000\002" +
    "\001\001\000\002\001\001\000\002\001\001\000\002\001" +
    "\001\000\012\025\221\026\152\027\150\030\132\001\001" +
    "\000\002\001\001\000\024\026\061\030\064\034\045\035" +
    "\224\040\223\041\053\042\065\043\043\044\050\001\001" +
    "\000\002\001\001\000\002\001\001\000\002\001\001\000" +
    "\002\001\001\000\002\001\001\000\002\001\001\000\004" +
    "\063\237\001\001\000\002\001\001\000\002\001\001\000" +
    "\002\001\001\000\002\001\001\000\004\022\241\001\001" +
    "\000\002\001\001\000\002\001\001\000\002\001\001\000" +
    "\002\001\001\000\002\001\001\000\002\001\001\000\002" +
    "\001\001\000\002\001\001\000\002\001\001\000\004\061" +
    "\034\001\001\000\002\001\001\000\002\001\001\000\002" +
    "\001\001\000\002\001\001\000\002\001\001\000\002\001" +
    "\001\000\002\001\001\000\002\001\001\000\002\001\001" +
    "\000\004\062\267\001\001\000\002\001\001\000\002\001" +
    "\001\000\004\035\266\001\001\000\002\001\001\000\004" +
    "\023\270\001\001\000\004\035\271\001\001\000\002\001" +
    "\001\000\006\015\076\061\034\001\001\000\030\003\274" +
    "\004\017\005\012\006\021\007\016\010\010\012\025\014" +
    "\023\017\015\020\014\021\020\001\001\000\002\001\001" +
    "\000\002\001\001\000\004\055\277\001\001\000\002\001" +
    "\001\000\002\001\001\000\002\001\001" });

  /** Access to <code>reduce_goto</code> table. */
  public short[][] reduce_table() {return _reduce_table;}

  /** Instance of action encapsulation class. */
  protected CUP$parser$actions action_obj;

  /** Action encapsulation object initializer. */
  protected void init_actions()
    {
      action_obj = new CUP$parser$actions(this);
    }

  /** Invoke a user supplied parse action. */
  public java_cup.runtime.Symbol do_action(
    int                        act_num,
    java_cup.runtime.lr_parser parser,
    java.util.Stack            stack,
    int                        top)
    throws java.lang.Exception
  {
    /* call code in generated class */
    return action_obj.CUP$parser$do_action(act_num, parser, stack, top);
  }

  /** Indicates start state. */
  public int start_state() {return 0;}
  /** Indicates start production. */
  public int start_production() {return 0;}

  /** <code>EOF</code> Symbol index. */
  public int EOF_sym() {return 0;}

  /** <code>error</code> Symbol index. */
  public int error_sym() {return 1;}



	SyntaxErrorManager        syntaxErrorManager   = CompilerContext.getSyntaxErrorManager();
	
	
	public void syntax_error(Symbol symbol)
	{

	    Token token = (Token) symbol.value;
	    syntaxErrorManager.syntaxError ("Error sintactico", token);	    
	}
		
	public void unrecovered_syntax_error(java_cup.runtime.Symbol symbol)
	{	
	    Token token = (Token) symbol.value;
	    syntaxErrorManager.syntaxFatalError ("Error fatal", token);
	    
	}

}

/** Cup generated class to encapsulate user supplied action code.*/
class CUP$parser$actions {


	
	SyntaxErrorManager        syntaxErrorManager   = CompilerContext.getSyntaxErrorManager();
	SemanticErrorManager      semanticErrorManager = CompilerContext.getSemanticErrorManager ();
	ScopeManagerIF            scopeManager         = CompilerContext.getScopeManager ();
	FinalCodeFactoryIF        finalCodeFactory     = CompilerContext.getFinalCodeFactory ();


  private final parser parser;

  /** Constructor */
  CUP$parser$actions(parser parser) {
    this.parser = parser;
  }

  /** Method with the actual generated action code. */
  public final java_cup.runtime.Symbol CUP$parser$do_action(
    int                        CUP$parser$act_num,
    java_cup.runtime.lr_parser CUP$parser$parser,
    java.util.Stack            CUP$parser$stack,
    int                        CUP$parser$top)
    throws java.lang.Exception
    {
      /* Symbol object for return from actions */
      java_cup.runtime.Symbol CUP$parser$result;

      /* select the action based on the action number */
      switch (CUP$parser$act_num)
        {
          /*. . . . . . . . . . . . . . . . . . . .*/
          case 100: // retorno_funcion ::= RETURN PUNTOYCOMA 
            {
              Object RESULT =null;
		
						Sentencia_simple simple = new Sentencia_simple();
						simple.setTipo("returnVacio");
						RESULT = simple;
						
						
              CUP$parser$result = parser.getSymbolFactory().newSymbol("retorno_funcion",26, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 99: // retorno_funcion ::= RETURN expresion PUNTOYCOMA 
            {
              Object RESULT =null;
		int exleft = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)).left;
		int exright = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)).right;
		Object ex = (Object)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-1)).value;
		 
	
					Expresion expresion = (Expresion)ex;
					Sentencia_simple simple = new Sentencia_simple();
					simple.setEx(expresion);
					simple.setTipo("return");
					RESULT = simple;
						
              CUP$parser$result = parser.getSymbolFactory().newSymbol("retorno_funcion",26, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 98: // sentencia_printc ::= PRINTC PARIZQ CADENA PARDER PUNTOYCOMA 
            {
              Object RESULT =null;
		int cadenaleft = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)).left;
		int cadenaright = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)).right;
		Token cadena = (Token)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-2)).value;
		 
					Sentencia_printc printc = new Sentencia_printc(cadena.getLexema());
					RESULT = printc;
	
	
              CUP$parser$result = parser.getSymbolFactory().newSymbol("sentencia_printc",34, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-4)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 97: // sentencia_printi ::= PRINTI PARIZQ PARDER PUNTOYCOMA 
            {
              Object RESULT =null;

              CUP$parser$result = parser.getSymbolFactory().newSymbol("sentencia_printi",33, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-3)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 96: // sentencia_printi ::= PRINTI PARIZQ expresion PARDER PUNTOYCOMA 
            {
              Object RESULT =null;
		int exleft = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)).left;
		int exright = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)).right;
		Object ex = (Object)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-2)).value;
		
						Expresion expresion = (Expresion)ex;
						Sentencia_simple simple = new Sentencia_simple();
						simple.setEx(expresion);
						simple.setTipo("printi");
						RESULT = simple;
	
	
              CUP$parser$result = parser.getSymbolFactory().newSymbol("sentencia_printi",33, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-4)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 95: // sentencia_while ::= WHILE PARIZQ expresion PARDER bloque_sentencias 
            {
              Object RESULT =null;
		int pleft = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-3)).left;
		int pright = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-3)).right;
		Token p = (Token)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-3)).value;
		int exleft = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)).left;
		int exright = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)).right;
		Object ex = (Object)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-2)).value;
		int bloqueleft = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).left;
		int bloqueright = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).right;
		Object bloque = (Object)((java_cup.runtime.Symbol) CUP$parser$stack.peek()).value;
		
						
						Expresion expresion = (Expresion)ex;

					if (expresion.getValor()==0 || expresion.getValor()==1) {
						Sentencia_While sWhile = new Sentencia_While();
						sWhile.setS1((Bloque_sentencias)bloque);
						RESULT = sWhile;
					}

					else
						semanticErrorManager.semanticFatalError("Error. Se esperaba una expresion logica en la linea " + p.getLine());
					
					
					
              CUP$parser$result = parser.getSymbolFactory().newSymbol("sentencia_while",32, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-4)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 94: // sentencia_while ::= WHILE PARIZQ expresion PARDER sentencia 
            {
              Object RESULT =null;
		int pleft = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-3)).left;
		int pright = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-3)).right;
		Token p = (Token)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-3)).value;
		int exleft = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)).left;
		int exright = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)).right;
		Object ex = (Object)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-2)).value;
		int senleft = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).left;
		int senright = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).right;
		Object sen = (Object)((java_cup.runtime.Symbol) CUP$parser$stack.peek()).value;
		
	

	Expresion expresion = (Expresion)ex;

	if (expresion.getValor()==0 || expresion.getValor()==1) {
		Sentencia_While sWhile = new Sentencia_While();
		sWhile.setS1((Bloque_sentencias)sen);
		RESULT = sWhile;
	}

	else
		semanticErrorManager.semanticFatalError("Error. Se esperaba una expresion logica en la linea " + p.getLine());





              CUP$parser$result = parser.getSymbolFactory().newSymbol("sentencia_while",32, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-4)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 93: // sentencia_if ::= IF PARIZQ expresion PARDER bloque_sentencias ELSE bloque_sentencias 
            {
              Object RESULT =null;
		int pleft = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-5)).left;
		int pright = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-5)).right;
		Token p = (Token)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-5)).value;
		int exleft = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-4)).left;
		int exright = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-4)).right;
		Object ex = (Object)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-4)).value;
		int bloque1left = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)).left;
		int bloque1right = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)).right;
		Object bloque1 = (Object)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-2)).value;
		int bloque2left = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).left;
		int bloque2right = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).right;
		Object bloque2 = (Object)((java_cup.runtime.Symbol) CUP$parser$stack.peek()).value;
		
						Expresion expresion = (Expresion)ex;
					
						if (expresion.getValor()==0 || expresion.getValor()==1) {
							SentenciaIF sIF = new SentenciaIF((Expresion)ex, true);
							sIF.setS1((Bloque_sentencias)bloque1);
							sIF.setS2((Bloque_sentencias)bloque2);
							RESULT = sIF;
				}

				else
					semanticErrorManager.semanticFatalError("Error. Se esperaba una expresion logica en la linea " + p.getLine());
					
						
						
						
						
              CUP$parser$result = parser.getSymbolFactory().newSymbol("sentencia_if",31, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-6)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 92: // sentencia_if ::= IF PARIZQ expresion PARDER bloque_sentencias ELSE sentencia 
            {
              Object RESULT =null;
		int pleft = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-5)).left;
		int pright = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-5)).right;
		Token p = (Token)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-5)).value;
		int exleft = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-4)).left;
		int exright = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-4)).right;
		Object ex = (Object)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-4)).value;
		int bloqueleft = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)).left;
		int bloqueright = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)).right;
		Object bloque = (Object)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-2)).value;
		int senleft = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).left;
		int senright = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).right;
		Object sen = (Object)((java_cup.runtime.Symbol) CUP$parser$stack.peek()).value;
		
						Expresion expresion = (Expresion)ex;
					
						if (expresion.getValor()==0 || expresion.getValor()==1) {
							SentenciaIF sIF = new SentenciaIF((Expresion)ex, true);
							sIF.setS1((Bloque_sentencias)bloque);
							sIF.setS2((Bloque_sentencias)sen);
							RESULT = sIF;
				}

				else
					semanticErrorManager.semanticFatalError("Error. Se esperaba una expresion logica en la linea " + p.getLine());
					
						
						
						
						
              CUP$parser$result = parser.getSymbolFactory().newSymbol("sentencia_if",31, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-6)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 91: // sentencia_if ::= IF PARIZQ expresion PARDER sentencia ELSE bloque_sentencias 
            {
              Object RESULT =null;
		int pleft = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-5)).left;
		int pright = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-5)).right;
		Token p = (Token)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-5)).value;
		int exleft = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-4)).left;
		int exright = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-4)).right;
		Object ex = (Object)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-4)).value;
		int senleft = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)).left;
		int senright = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)).right;
		Object sen = (Object)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-2)).value;
		int bloqueleft = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).left;
		int bloqueright = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).right;
		Object bloque = (Object)((java_cup.runtime.Symbol) CUP$parser$stack.peek()).value;
		
						Expresion expresion = (Expresion)ex;
				
						if (expresion.getValor()==0 || expresion.getValor()==1) {
							SentenciaIF sIF = new SentenciaIF((Expresion)ex, true);
							sIF.setS1((Bloque_sentencias)sen);
							sIF.setS2((Bloque_sentencias)bloque);
							RESULT = sIF;
					}

					else
						semanticErrorManager.semanticFatalError("Error. Se esperaba una expresion logica en la linea " + p.getLine());
						
						
						
              CUP$parser$result = parser.getSymbolFactory().newSymbol("sentencia_if",31, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-6)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 90: // sentencia_if ::= IF PARIZQ expresion PARDER sentencia ELSE sentencia 
            {
              Object RESULT =null;
		int pleft = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-5)).left;
		int pright = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-5)).right;
		Token p = (Token)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-5)).value;
		int exleft = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-4)).left;
		int exright = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-4)).right;
		Object ex = (Object)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-4)).value;
		int s1left = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)).left;
		int s1right = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)).right;
		Object s1 = (Object)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-2)).value;
		int s2left = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).left;
		int s2right = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).right;
		Object s2 = (Object)((java_cup.runtime.Symbol) CUP$parser$stack.peek()).value;
		
						
						Expresion expresion = (Expresion)ex;
						if (expresion.getValor()==0 || expresion.getValor()==1) {
							SentenciaIF sIF = new SentenciaIF((Expresion)ex, true);
							sIF.setS1((Bloque_sentencias)s1);
							sIF.setS2((Bloque_sentencias)s2);
							RESULT = sIF;
						}
	
						else
							semanticErrorManager.semanticFatalError("Error. Se esperaba una expresion logica en la linea " + p.getLine());

				
				
				
              CUP$parser$result = parser.getSymbolFactory().newSymbol("sentencia_if",31, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-6)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 89: // sentencia_if ::= IF PARIZQ expresion PARDER bloque_sentencias 
            {
              Object RESULT =null;
		int pleft = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-3)).left;
		int pright = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-3)).right;
		Token p = (Token)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-3)).value;
		int exleft = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)).left;
		int exright = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)).right;
		Object ex = (Object)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-2)).value;
		int sleft = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).left;
		int sright = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).right;
		Object s = (Object)((java_cup.runtime.Symbol) CUP$parser$stack.peek()).value;
		
						
					Expresion expresion = (Expresion)ex;	
					if (expresion.getValor()==0 || expresion.getValor()==1) {
	
						SentenciaIF sIF = new SentenciaIF((Expresion)ex, false);
						sIF.setS1((Bloque_sentencias)s);
						RESULT = sIF;
					}
					
					else
						semanticErrorManager.semanticFatalError("Error. Se esperaba una expresion logica en la linea " + p.getLine());
				
				
              CUP$parser$result = parser.getSymbolFactory().newSymbol("sentencia_if",31, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-4)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 88: // sentencia_if ::= IF PARIZQ expresion PARDER sentencia 
            {
              Object RESULT =null;
		int pleft = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-3)).left;
		int pright = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-3)).right;
		Token p = (Token)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-3)).value;
		int exleft = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)).left;
		int exright = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)).right;
		Object ex = (Object)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-2)).value;
		int senleft = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).left;
		int senright = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).right;
		Object sen = (Object)((java_cup.runtime.Symbol) CUP$parser$stack.peek()).value;
		
			Expresion expresion = (Expresion)ex;
			
			if (expresion.getValor()==0 || expresion.getValor()==1) {
				SentenciaIF sIF = new SentenciaIF((Expresion)ex, false);
				sIF.setS1((Bloque_sentencias)sen);
				RESULT = sIF;
			}
			else
				semanticErrorManager.semanticFatalError("Error. Se esperaba una expresion logica en la linea " + p.getLine());

	
	
	
              CUP$parser$result = parser.getSymbolFactory().newSymbol("sentencia_if",31, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-4)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 87: // parametro ::= IDENTIFICADOR rango_matriz rango_matriz 
            {
              Object RESULT =null;
		int idleft = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)).left;
		int idright = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)).right;
		Token id = (Token)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-2)).value;
		int r1left = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)).left;
		int r1right = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)).right;
		Object r1 = (Object)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-1)).value;
		int r2left = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).left;
		int r2right = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).right;
		Object r2 = (Object)((java_cup.runtime.Symbol) CUP$parser$stack.peek()).value;
		
					ScopeIF sc = scopeManager.getCurrentScope();
					SymbolTableIF ts = sc.getSymbolTable();
					
					if (ts.containsSymbol(id.getLexema())) {
						RESULT = id.getLexema();
						SymbolMatrix sMatrix =(SymbolMatrix) (ts.getSymbol(id.getLexema()));
						if(sMatrix.getDefinido((int)r1,(int)r2))
							RESULT = id.getLexema();
						
						else
							semanticErrorManager.semanticFatalError("Error. El valor " + id.getLexema() + "[" + r1 +"][" + r2 + "] no ha sido definido en la linea " + id.getLine());


						
					}
					else
						semanticErrorManager.semanticFatalError("Error. Identificador " + id.getLexema() + " no definido en la llamada a la funcion en la linea " + id.getLine());
					
					
					
					
              CUP$parser$result = parser.getSymbolFactory().newSymbol("parametro",25, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 86: // parametro ::= IDENTIFICADOR 
            {
              Object RESULT =null;
		int idleft = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).left;
		int idright = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).right;
		Token id = (Token)((java_cup.runtime.Symbol) CUP$parser$stack.peek()).value;
		
		
		ScopeIF sc = scopeManager.getCurrentScope();
		SymbolTableIF ts = sc.getSymbolTable();
		
		if (scopeManager.containsSymbol(id.getLexema())) {
			RESULT = id.getLexema();
	
			}
		else
			semanticErrorManager.semanticFatalError("Error. Identificador " + id.getLexema() + " no definido en la llamada a la funcion en la linea " + id.getLine());


	
	
	
	
              CUP$parser$result = parser.getSymbolFactory().newSymbol("parametro",25, ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 85: // parametros ::= parametros COMA parametro 
            {
              Object RESULT =null;
		int paramsleft = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)).left;
		int paramsright = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)).right;
		Object params = (Object)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-2)).value;
		int paramleft = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).left;
		int paramright = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).right;
		Object param = (Object)((java_cup.runtime.Symbol) CUP$parser$stack.peek()).value;
		
					ArrayList<String> pFuncion = new ArrayList<String>();
					
					if (params instanceof ArrayList) {
						pFuncion = (ArrayList<String>)params;
					}
					else
						pFuncion.add((String)params);
					
					pFuncion.add((String)param);
					
					RESULT = pFuncion;
					
					
					
					
              CUP$parser$result = parser.getSymbolFactory().newSymbol("parametros",24, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 84: // parametros ::= parametro 
            {
              Object RESULT =null;
		int paramleft = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).left;
		int paramright = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).right;
		Object param = (Object)((java_cup.runtime.Symbol) CUP$parser$stack.peek()).value;
		
			RESULT = param;
	
	
              CUP$parser$result = parser.getSymbolFactory().newSymbol("parametros",24, ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 83: // lista_parametros ::= PARIZQ parametros PARDER 
            {
              Object RESULT =null;
		int paramleft = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)).left;
		int paramright = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)).right;
		Object param = (Object)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-1)).value;
		
						 if (param instanceof ArrayList)
							 RESULT = param;
						 else {
							 ArrayList<String> pFuncion = new ArrayList<String>();
							 pFuncion.add((String)param);
							 RESULT = pFuncion;
						 }
						 
						
              CUP$parser$result = parser.getSymbolFactory().newSymbol("lista_parametros",23, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 82: // lista_parametros ::= PARIZQ PARDER 
            {
              Object RESULT =null;

              CUP$parser$result = parser.getSymbolFactory().newSymbol("lista_parametros",23, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 81: // llamada_funcion ::= IDENTIFICADOR lista_parametros 
            {
              Object RESULT =null;
		int idleft = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)).left;
		int idright = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)).right;
		Token id = (Token)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-1)).value;
		int listaleft = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).left;
		int listaright = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).right;
		Object lista = (Object)((java_cup.runtime.Symbol) CUP$parser$stack.peek()).value;
		
	
				ScopeIF sc = scopeManager.getCurrentScope();
				SymbolTableIF ts = sc.getSymbolTable();
				
				if ( scopeManager.containsSymbol(id.getLexema())) {
					SymbolFunction sFunction = (SymbolFunction)scopeManager.searchSymbol(id.getLexema());
					Declar_funcion funcion = sFunction.getFuncion();
					funcion.compruebaParametros(scopeManager,semanticErrorManager,(ArrayList<String>)lista,id.getLine());
					/*Declar_parametros dParametros = funcion.getParametros();
					ArrayList<String>listaDeclarados= dParametros.getListaIds();
					ArrayList<String>listaLlamados = (ArrayList<String>) lista;*/
					LLamada_funcion llamada = new LLamada_funcion();
					llamada.setId(id.getLexema());
					llamada.setListaIds((ArrayList<String>)lista);
					RESULT = llamada;
					
				}
				
				else
					semanticErrorManager.semanticFatalError("Error. Funcion " + id.getLexema() + " no definida en la linea " + id.getLine() );
	
	
	
	
              CUP$parser$result = parser.getSymbolFactory().newSymbol("llamada_funcion",22, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 80: // expresion ::= asignacion 
            {
              Object RESULT =null;
		int asigleft = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).left;
		int asigright = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).right;
		Object asig = (Object)((java_cup.runtime.Symbol) CUP$parser$stack.peek()).value;
		
					RESULT=asig;
					
					
              CUP$parser$result = parser.getSymbolFactory().newSymbol("expresion",19, ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 79: // expresion ::= expresion_sin_asign 
            {
              Object RESULT =null;
		int exleft = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).left;
		int exright = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).right;
		Object ex = (Object)((java_cup.runtime.Symbol) CUP$parser$stack.peek()).value;
		 
		
			RESULT=ex;
		
			
	
              CUP$parser$result = parser.getSymbolFactory().newSymbol("expresion",19, ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 78: // expresion_sin_asign ::= PARIZQ expresion PARDER 
            {
              Object RESULT =null;
		int expleft = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)).left;
		int expright = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)).right;
		Object exp = (Object)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-1)).value;
		
							RESULT= exp;
							
              CUP$parser$result = parser.getSymbolFactory().newSymbol("expresion_sin_asign",21, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 77: // expresion_sin_asign ::= expresion_sin_asign AND expresion_sin_asign 
            {
              Object RESULT =null;
		int ex1left = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)).left;
		int ex1right = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)).right;
		Object ex1 = (Object)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-2)).value;
		int aleft = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)).left;
		int aright = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)).right;
		Token a = (Token)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-1)).value;
		int ex2left = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).left;
		int ex2right = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).right;
		Object ex2 = (Object)((java_cup.runtime.Symbol) CUP$parser$stack.peek()).value;
		
						
							Expresion exp1 = (Expresion)ex1;
							Expresion exp2 = (Expresion)ex2;
							int valor;
							boolean valor1=false;
							boolean valor2=false;
							
							if (exp1.getValor()==1)
								valor1 = true;
							else {
								if (exp1.getValor()==0)
									valor1 = false;
								else
									semanticErrorManager.semanticFatalError("Error. El valor " + exp1.getValor() + " no es un valor lógico en la linea " + a.getLine());
								}
							
							if (exp2.getValor()==1)
								valor2 = true;
							else {
								if (exp2.getValor()==0)
									valor2 = false;
								else
									semanticErrorManager.semanticFatalError("Error. El valor " + exp2.getValor() + " no es un valor lógico en la linea " + a.getLine());
								}
							
							
							if (valor1 && valor2)
								valor=1;
							else
								valor=0;
							
							ExpresionCompuesta expCompuesta = new ExpresionCompuesta(valor, "tipoCompuesto",(Expresion) ex1,(Expresion) ex2);
						
					
							RESULT = expCompuesta;
							
							
              CUP$parser$result = parser.getSymbolFactory().newSymbol("expresion_sin_asign",21, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 76: // expresion_sin_asign ::= expresion_sin_asign DISTINTO expresion_sin_asign 
            {
              Object RESULT =null;
		int ex1left = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)).left;
		int ex1right = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)).right;
		Object ex1 = (Object)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-2)).value;
		int ex2left = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).left;
		int ex2right = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).right;
		Object ex2 = (Object)((java_cup.runtime.Symbol) CUP$parser$stack.peek()).value;
		
							
							Expresion exp1 = (Expresion)ex1;
							Expresion exp2 = (Expresion)ex2;
							int valor;
							if (exp1.getValor() != exp2.getValor())
								valor=1;
							else
								valor=0;
							ExpresionCompuesta expCompuesta = new ExpresionCompuesta(valor,"tipoCompuesto", (Expresion)ex1,(Expresion)ex2);
							
						
							RESULT = expCompuesta;
						
							
							
							
              CUP$parser$result = parser.getSymbolFactory().newSymbol("expresion_sin_asign",21, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 75: // expresion_sin_asign ::= expresion_sin_asign MENOR expresion_sin_asign 
            {
              Object RESULT =null;
		int ex1left = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)).left;
		int ex1right = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)).right;
		Object ex1 = (Object)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-2)).value;
		int ex2left = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).left;
		int ex2right = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).right;
		Object ex2 = (Object)((java_cup.runtime.Symbol) CUP$parser$stack.peek()).value;
		
						
							Expresion exp1 = (Expresion)ex1;
							Expresion exp2 = (Expresion)ex2;
							int valor;
							
							if (exp1.getValor() < exp2.getValor())
								valor=1;
							else
								valor=0;
							ExpresionCompuesta expCompuesta = new ExpresionCompuesta(valor,"tipoCompuesto", (Expresion)ex1, (Expresion)ex2);
							
							
							RESULT = expCompuesta;
						
							
              CUP$parser$result = parser.getSymbolFactory().newSymbol("expresion_sin_asign",21, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 74: // expresion_sin_asign ::= expresion_sin_asign MAS expresion_sin_asign 
            {
              Object RESULT =null;
		int ex1left = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)).left;
		int ex1right = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)).right;
		Object ex1 = (Object)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-2)).value;
		int masleft = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)).left;
		int masright = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)).right;
		Token mas = (Token)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-1)).value;
		int ex2left = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).left;
		int ex2right = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).right;
		Object ex2 = (Object)((java_cup.runtime.Symbol) CUP$parser$stack.peek()).value;
		
							Expresion exp1 = (Expresion)ex1;
 							Expresion exp2 = (Expresion)ex2;
							ExpresionCompuesta expCompuesta = new ExpresionCompuesta(exp1.getValor()+exp2.getValor(),"tipoCompuesto", (Expresion)ex1, (Expresion)ex2);
 							
								
								RESULT= expCompuesta;
					
							
							
							
              CUP$parser$result = parser.getSymbolFactory().newSymbol("expresion_sin_asign",21, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 73: // expresion_sin_asign ::= llamada_funcion 
            {
              Object RESULT =null;

              CUP$parser$result = parser.getSymbolFactory().newSymbol("expresion_sin_asign",21, ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 72: // expresion_sin_asign ::= IDENTIFICADOR rango_matriz rango_matriz 
            {
              Object RESULT =null;
		int idleft = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)).left;
		int idright = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)).right;
		Token id = (Token)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-2)).value;
		int r1left = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)).left;
		int r1right = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)).right;
		Object r1 = (Object)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-1)).value;
		int r2left = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).left;
		int r2right = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).right;
		Object r2 = (Object)((java_cup.runtime.Symbol) CUP$parser$stack.peek()).value;
		
							ScopeIF sc = scopeManager.getCurrentScope();
 							SymbolTableIF ts = sc.getSymbolTable();
 							if (scopeManager.containsSymbol(id.getLexema())) {
 								SymbolMatrix sMatrix = (SymbolMatrix)scopeManager.searchSymbol(id.getLexema());
 								if (sMatrix.rangoCorrecto((int)r1,(int)r2)) {
 									if (sMatrix.getDefinido((int)r1,(int)r2)) {
 										ExpresionMatriz expMatriz = new ExpresionMatriz(sMatrix.getValor((int)r1,(int)r2),id.getLexema(),(int)r1,(int)r2);
 										RESULT= expMatriz;
 									}
 									else
 	 									semanticErrorManager.semanticFatalError("Error. La posicion [" + (int)r1 + "][" + (int)r2 + "] de la matriz "+ id.getLexema() + " no esta definida en la linea " + id.getLine());

 									
 								
 								}
 								else
 									semanticErrorManager.semanticFatalError("Error. La matriz " + id.getLexema() + " esta fuera de rango en la linea " + id.getLine());
 							
 							}	
 						
 							else {
 								semanticErrorManager.semanticFatalError("Error. La matriz " + id.getLexema() + " no ha sido declarada en la linea " + id.getLine());
 							}
 						
							
							
							
              CUP$parser$result = parser.getSymbolFactory().newSymbol("expresion_sin_asign",21, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 71: // expresion_sin_asign ::= IDENTIFICADOR 
            {
              Object RESULT =null;
		int idleft = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).left;
		int idright = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).right;
		Token id = (Token)((java_cup.runtime.Symbol) CUP$parser$stack.peek()).value;
		
							ScopeIF sc = scopeManager.getCurrentScope();
 							SymbolTableIF ts = sc.getSymbolTable();
 						if (scopeManager.containsSymbol(id.getLexema())) {
 							SymbolIF simbolo = scopeManager.searchSymbol(id.getLexema());
 							if (((simbolo.getType()).getName()).equals("Entero")) {
 								if (simbolo instanceof SymbolVariable) {
 									 ExpresionId expId = new ExpresionId(((SymbolVariable)simbolo).getValor(),id.getLexema());
 									 RESULT = expId;
 								}

								else {
									 ExpresionId expId = new ExpresionId(((SymbolConstant)simbolo).getValor(),id.getLexema());
 									 RESULT = expId;

								}
 							}
 							else
 									semanticErrorManager.semanticFatalError("Error. Identificador no válido " + id.getLexema() + " en la linea " + id.getLine());
 									
								
							
 						}
 						
 						else
 							semanticErrorManager.semanticFatalError("Error. Identificador " + id.getLexema() + " no encontrado en la linea " + id.getLine());
							
              CUP$parser$result = parser.getSymbolFactory().newSymbol("expresion_sin_asign",21, ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 70: // expresion_sin_asign ::= NUMERO 
            {
              Object RESULT =null;
		int numleft = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).left;
		int numright = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).right;
		Token num = (Token)((java_cup.runtime.Symbol) CUP$parser$stack.peek()).value;
		
			if (TypeSimple.rangoCorrecto(Integer.parseInt(num.getLexema()))){
				Expresion exp = new Expresion(Integer.parseInt(num.getLexema()),"tipoEntero");
				RESULT= exp;
				}
			else
				semanticErrorManager.semanticFatalError("Error. El número " + num.getLexema() + " esta fuera de rango en la linea " + num.getLine());

				
				
	
              CUP$parser$result = parser.getSymbolFactory().newSymbol("expresion_sin_asign",21, ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 69: // asignacion ::= IDENTIFICADOR rango_matriz rango_matriz ASIGNACION expresion_sin_asign 
            {
              Object RESULT =null;
		int idleft = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-4)).left;
		int idright = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-4)).right;
		Token id = (Token)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-4)).value;
		int r1left = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-3)).left;
		int r1right = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-3)).right;
		Object r1 = (Object)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-3)).value;
		int r2left = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)).left;
		int r2right = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)).right;
		Object r2 = (Object)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-2)).value;
		int exleft = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).left;
		int exright = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).right;
		Object ex = (Object)((java_cup.runtime.Symbol) CUP$parser$stack.peek()).value;
		
 						
 						ScopeIF sc = scopeManager.getCurrentScope();
 						SymbolTableIF ts = sc.getSymbolTable();
 						if (scopeManager.containsSymbol(id.getLexema())) {
 							SymbolMatrix sMatrix = (SymbolMatrix)scopeManager.searchSymbol(id.getLexema());
 							if (sMatrix.rangoCorrecto((int)r1,(int)r2)) {
 								sMatrix.setValor((int)r1,(int)r2, ((Expresion)ex).getValor());
 								ts.addSymbol(sMatrix);
 								ExpresionMatriz exp1 = new ExpresionMatriz(((Expresion)ex).getValor(),id.getLexema(), (int)r1,(int)r2);
								ExpresionCompuesta expCompuesta = new ExpresionCompuesta(((Expresion)ex).getValor(), "tipoAsignacion", exp1, (Expresion)ex);
								RESULT =expCompuesta;
 								
 							}
 							else
 								semanticErrorManager.semanticFatalError("Error. La matriz " + id.getLexema() + " esta fuera de rango en la linea " + id.getLine());
 							
 						}	
 						
 						else {
 							semanticErrorManager.semanticFatalError("Error. La matriz " + id.getLexema() + " no ha sido declarada en la linea " + id.getLine());
 						}
 						
 						
 						
              CUP$parser$result = parser.getSymbolFactory().newSymbol("asignacion",20, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-4)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 68: // asignacion ::= IDENTIFICADOR ASIGNACION expresion_sin_asign 
            {
              Object RESULT =null;
		int idleft = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)).left;
		int idright = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)).right;
		Token id = (Token)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-2)).value;
		int exleft = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).left;
		int exright = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).right;
		Object ex = (Object)((java_cup.runtime.Symbol) CUP$parser$stack.peek()).value;
		 	
					ScopeIF sc = scopeManager.getCurrentScope();
					SymbolTableIF ts = sc.getSymbolTable();
						if (scopeManager.containsSymbol(id.getLexema())) {
							SymbolIF simbolo = scopeManager.searchSymbol(id.getLexema());
							if (((simbolo.getType()).getName()).equals("Entero")) {
								if (simbolo instanceof SymbolVariable) {
									SymbolVariable sVariable = (SymbolVariable)simbolo;
									sVariable.setValor(((Expresion)ex).getValor());
									ts.addSymbol(sVariable);
									ExpresionId exp1 = new ExpresionId(((Expresion)ex).getValor(),id.getLexema());
									ExpresionCompuesta expCompuesta = new ExpresionCompuesta(((Expresion)ex).getValor(), "tipoAsignacion", exp1, (Expresion)ex);
									
									System.out.println(ts);
									RESULT = expCompuesta; 
								}

								else {
									semanticErrorManager.semanticFatalError("Error. No se puede asignar un valor a la constante " + id.getLexema() + " en la linea " + id.getLine());

								}
							}
							else
								semanticErrorManager.semanticFatalError("Error. Identificador no válido " + id.getLexema() + " en la linea " + id.getLine());
			
	

						}
					
						
              CUP$parser$result = parser.getSymbolFactory().newSymbol("asignacion",20, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 67: // sentencia ::= retorno_funcion 
            {
              Object RESULT =null;
		int senleft = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).left;
		int senright = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).right;
		Object sen = (Object)((java_cup.runtime.Symbol) CUP$parser$stack.peek()).value;
		
				RESULT = (Sentencia)sen;
			
			
              CUP$parser$result = parser.getSymbolFactory().newSymbol("sentencia",30, ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 66: // sentencia ::= llamada_funcion PUNTOYCOMA 
            {
              Object RESULT =null;
		int senleft = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)).left;
		int senright = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)).right;
		Object sen = (Object)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-1)).value;
		
				RESULT = (Sentencia)sen;
			
			
              CUP$parser$result = parser.getSymbolFactory().newSymbol("sentencia",30, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 65: // sentencia ::= asignacion PUNTOYCOMA 
            {
              Object RESULT =null;
		int asigleft = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)).left;
		int asigright = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)).right;
		Object asig = (Object)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-1)).value;
		
				RESULT = (ExpresionCompuesta)asig;
			
			
              CUP$parser$result = parser.getSymbolFactory().newSymbol("sentencia",30, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 64: // sentencia ::= sentencia_printc 
            {
              Object RESULT =null;
		int senleft = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).left;
		int senright = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).right;
		Object sen = (Object)((java_cup.runtime.Symbol) CUP$parser$stack.peek()).value;
		
				RESULT = (Sentencia_printc)sen;
			
			
              CUP$parser$result = parser.getSymbolFactory().newSymbol("sentencia",30, ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 63: // sentencia ::= sentencia_printi 
            {
              Object RESULT =null;
		int senleft = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).left;
		int senright = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).right;
		Object sen = (Object)((java_cup.runtime.Symbol) CUP$parser$stack.peek()).value;
		
				RESULT = (Sentencia_simple)sen;
			
			
              CUP$parser$result = parser.getSymbolFactory().newSymbol("sentencia",30, ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 62: // sentencia ::= sentencia_while 
            {
              Object RESULT =null;
		int senleft = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).left;
		int senright = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).right;
		Object sen = (Object)((java_cup.runtime.Symbol) CUP$parser$stack.peek()).value;
		
				RESULT = (Sentencia_While)sen;
			
			
              CUP$parser$result = parser.getSymbolFactory().newSymbol("sentencia",30, ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 61: // sentencia ::= sentencia_if 
            {
              Object RESULT =null;
		int senleft = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).left;
		int senright = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).right;
		Object sen = (Object)((java_cup.runtime.Symbol) CUP$parser$stack.peek()).value;
		
		RESULT= (SentenciaIF)sen;
	
	
              CUP$parser$result = parser.getSymbolFactory().newSymbol("sentencia",30, ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 60: // sentencias ::= sentencia sentencias 
            {
              Object RESULT =null;
		int sen1left = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)).left;
		int sen1right = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)).right;
		Object sen1 = (Object)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-1)).value;
		int sen2left = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).left;
		int sen2right = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).right;
		Object sen2 = (Object)((java_cup.runtime.Symbol) CUP$parser$stack.peek()).value;
		
				Bloque_sentencias bloque_sen = (Bloque_sentencias)sen2;
				bloque_sen.addSentencia((Sentencia)sen1);
				bloque_sen.addSentencia((Sentencia)sen2);
				
				RESULT = bloque_sen;

				
				
				
              CUP$parser$result = parser.getSymbolFactory().newSymbol("sentencias",29, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 59: // sentencias ::= sentencia 
            {
              Object RESULT =null;
		int senleft = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).left;
		int senright = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).right;
		Object sen = (Object)((java_cup.runtime.Symbol) CUP$parser$stack.peek()).value;
		
				Bloque_sentencias bloque_sen = new Bloque_sentencias();
				bloque_sen.addSentencia((Sentencia)sen);
				RESULT = bloque_sen;
				
              CUP$parser$result = parser.getSymbolFactory().newSymbol("sentencias",29, ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 58: // sentencias ::= bloque_sentencias sentencias 
            {
              Object RESULT =null;
		int bloqueleft = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)).left;
		int bloqueright = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)).right;
		Object bloque = (Object)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-1)).value;
		int senleft = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).left;
		int senright = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).right;
		Object sen = (Object)((java_cup.runtime.Symbol) CUP$parser$stack.peek()).value;
		
				Bloque_sentencias bloque_sen = (Bloque_sentencias)sen;
				bloque_sen.addSentencia((Bloque_sentencias)bloque);
				bloque_sen.addSentencia((Sentencia)sen);
			
			RESULT = bloque_sen;
				
              CUP$parser$result = parser.getSymbolFactory().newSymbol("sentencias",29, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 57: // sentencias ::= bloque_sentencias 
            {
              Object RESULT =null;
		int bloqueleft = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).left;
		int bloqueright = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).right;
		Object bloque = (Object)((java_cup.runtime.Symbol) CUP$parser$stack.peek()).value;
		
			
			RESULT = (Bloque_sentencias)bloque;
	
              CUP$parser$result = parser.getSymbolFactory().newSymbol("sentencias",29, ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 56: // declar_variables ::= sentencias 
            {
              Object RESULT =null;
		int bloqueleft = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).left;
		int bloqueright = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).right;
		Object bloque = (Object)((java_cup.runtime.Symbol) CUP$parser$stack.peek()).value;
		
							Declaracion dec = new Declaracion();
							dec.setSentencias((Bloque_sentencias)bloque);
							RESULT = dec;

              CUP$parser$result = parser.getSymbolFactory().newSymbol("declar_variables",9, ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 55: // declar_variables ::= declar_variable 
            {
              Object RESULT =null;
		int listaleft = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).left;
		int listaright = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).right;
		Object lista = (Object)((java_cup.runtime.Symbol) CUP$parser$stack.peek()).value;
		
							
							Declaracion dec = new Declaracion();
							if (lista instanceof Lista_variables_Enteras)
								dec.addListaEnteras((Lista_variables_Enteras)lista);
							else
								dec.addListaMatrices((Lista_variables_matriz)lista);
							
							RESULT = dec;
							
              CUP$parser$result = parser.getSymbolFactory().newSymbol("declar_variables",9, ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 54: // declar_variables ::= declar_variable declar_variables 
            {
              Object RESULT =null;
		int declarleft = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)).left;
		int declarright = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)).right;
		Object declar = (Object)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-1)).value;
		int declaracionesleft = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).left;
		int declaracionesright = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).right;
		Object declaraciones = (Object)((java_cup.runtime.Symbol) CUP$parser$stack.peek()).value;
		
						Declaracion dec = (Declaracion)declar;
						
							if (declaraciones instanceof Lista_variables_Enteras) 
								dec.addListaEnteras((Lista_variables_Enteras)declaraciones);
							else {
								if (declaraciones instanceof Lista_variables_matriz)
									dec.addListaMatrices((Lista_variables_matriz)declaraciones);
								else {
									dec.setSentencias((Bloque_sentencias)declaraciones);
								}
								
							}
						
					if (declar instanceof Lista_variables_Enteras) 
							dec.addListaEnteras((Lista_variables_Enteras)declar);
						else {
							if (declar instanceof Lista_variables_matriz)
								dec.addListaMatrices((Lista_variables_matriz)declar);
							else {
								dec.setSentencias((Bloque_sentencias)declar);
								System.out.println("He pasado por aqui...");
							}
							
						}
					
				
						RESULT = dec;
						//Ojoooooo al añadir cosas........
						
              CUP$parser$result = parser.getSymbolFactory().newSymbol("declar_variables",9, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 53: // declar_tipos ::= declar_variables 
            {
              Object RESULT =null;
		int varleft = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).left;
		int varright = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).right;
		Object var = (Object)((java_cup.runtime.Symbol) CUP$parser$stack.peek()).value;
		
						RESULT = var;

              CUP$parser$result = parser.getSymbolFactory().newSymbol("declar_tipos",7, ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 52: // declar_tipos ::= declar_tipo 
            {
              Object RESULT =null;
		int tipoleft = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).left;
		int tiporight = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).right;
		Object tipo = (Object)((java_cup.runtime.Symbol) CUP$parser$stack.peek()).value;
		
						RESULT = tipo;
						
						
						
              CUP$parser$result = parser.getSymbolFactory().newSymbol("declar_tipos",7, ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 51: // declar_tipos ::= declar_tipo declar_tipos 
            {
              Object RESULT =null;
		int declarleft = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)).left;
		int declarright = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)).right;
		Object declar = (Object)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-1)).value;
		int declaracionesleft = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).left;
		int declaracionesright = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).right;
		Object declaraciones = (Object)((java_cup.runtime.Symbol) CUP$parser$stack.peek()).value;
		
					
					Declaracion dec = new Declaracion();
					if (declaraciones instanceof Declaracion){
						dec = (Declaracion)declaraciones;
					}
					
					else
						if (declaraciones instanceof Lista_variables_Enteras) 
							dec.addListaEnteras((Lista_variables_Enteras)declaraciones);
						else {
							if (declaraciones instanceof Lista_variables_matriz)
								dec.addListaMatrices((Lista_variables_matriz)declaraciones);
							else {
								if (declaraciones instanceof Bloque_sentencias)
									dec.setSentencias((Bloque_sentencias)declaraciones);
								else
									dec.addListaTipos((Declar_tipo)declaraciones);
							}
			
						}

					if (declar instanceof Lista_variables_Enteras) 
						dec.addListaEnteras((Lista_variables_Enteras)declar);
					else {
						if (declar instanceof Lista_variables_matriz)
							dec.addListaMatrices((Lista_variables_matriz)declar);
						else {
							if (declaraciones instanceof Bloque_sentencias)
								dec.setSentencias((Bloque_sentencias)declar);
							else
								dec.addListaTipos((Declar_tipo)declar);
							
						}
	
					}							
					RESULT = dec;
					
              CUP$parser$result = parser.getSymbolFactory().newSymbol("declar_tipos",7, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 50: // cuerpo_sentencias ::= declar_tipos 
            {
              Object RESULT =null;
		int declarleft = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).left;
		int declarright = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).right;
		Object declar = (Object)((java_cup.runtime.Symbol) CUP$parser$stack.peek()).value;
		
		RESULT = declar;
			
              CUP$parser$result = parser.getSymbolFactory().newSymbol("cuerpo_sentencias",28, ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 49: // bloque_sentencias ::= LLAVEIZQ NT$11 cuerpo_sentencias NT$12 LLAVEDER 
            {
              Object RESULT =null;
              // propagate RESULT from NT$12
                RESULT = (Object) ((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-1)).value;
		int cuerpoleft = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)).left;
		int cuerporight = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)).right;
		Object cuerpo = (Object)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-2)).value;
		
		scopeManager.closeScope();
		ScopeIF ambito = scopeManager.getCurrentScope();
		System.out.println("Tras cerrar bloque NO vacio"+ ambito);
		
              CUP$parser$result = parser.getSymbolFactory().newSymbol("bloque_sentencias",27, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-4)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 48: // NT$12 ::= 
            {
              Object RESULT =(Object) ((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-1)).value;
		int cuerpoleft = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).left;
		int cuerporight = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).right;
		Object cuerpo = (Object)((java_cup.runtime.Symbol) CUP$parser$stack.peek()).value;

		RESULT = cuerpo;
	
              CUP$parser$result = parser.getSymbolFactory().newSymbol("NT$12",52, ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 47: // NT$11 ::= 
            {
              Object RESULT =null;

	ScopeIF ambito = scopeManager.openScope();
	System.out.println("Tras abrir bloque NO vacio"+ ambito);
	
              CUP$parser$result = parser.getSymbolFactory().newSymbol("NT$11",51, ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 46: // bloque_sentencias ::= LLAVEIZQ NT$10 LLAVEDER 
            {
              Object RESULT =null;
              // propagate RESULT from NT$10
                RESULT = (Object) ((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-1)).value;

              CUP$parser$result = parser.getSymbolFactory().newSymbol("bloque_sentencias",27, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 45: // NT$10 ::= 
            {
              Object RESULT =null;

	ScopeIF ambito = scopeManager.openScope();
	System.out.println("Tras abrir bloque vacio"+ ambito);
	scopeManager.closeScope();ambito = scopeManager.getCurrentScope();
	System.out.println("Tras cerrar bloque vacio"+ ambito);
	
              CUP$parser$result = parser.getSymbolFactory().newSymbol("NT$10",50, ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 44: // tipo_parametros ::= IDENTIFICADOR 
            {
              Object RESULT =null;
		int idleft = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).left;
		int idright = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).right;
		Token id = (Token)((java_cup.runtime.Symbol) CUP$parser$stack.peek()).value;
		 
	
	semanticErrorManager.semanticFatalError("Error. No se pueden pasar tipos estructurados como parametros en la linea  " + id.getLine());

	
	
              CUP$parser$result = parser.getSymbolFactory().newSymbol("tipo_parametros",16, ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 43: // tipo_parametros ::= ENTERO 
            {
              Object RESULT =null;
		
			ScopeIF sc = scopeManager.getCurrentScope();
			TypeIF tipo = scopeManager.searchType("Entero");

			RESULT = tipo;
	
			
              CUP$parser$result = parser.getSymbolFactory().newSymbol("tipo_parametros",16, ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 42: // lista_declar_parametros ::= lista_declar_parametros COMA tipo_parametros REFERENCIA IDENTIFICADOR 
            {
              Object RESULT =null;
		int paramleft = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-4)).left;
		int paramright = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-4)).right;
		Object param = (Object)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-4)).value;
		int tipoleft = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)).left;
		int tiporight = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)).right;
		Object tipo = (Object)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-2)).value;
		int idleft = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).left;
		int idright = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).right;
		Token id = (Token)((java_cup.runtime.Symbol) CUP$parser$stack.peek()).value;
		
								
					 			Declar_parametros parametros = new Declar_parametros();
								
								if (param != null)
									parametros = (Declar_parametros) param;
								
								
								parametros.addTipo((TypeIF)tipo);
								parametros.addId(id.getLexema());
								RESULT = parametros;
								
					 			
					 			
              CUP$parser$result = parser.getSymbolFactory().newSymbol("lista_declar_parametros",18, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-4)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 41: // lista_declar_parametros ::= tipo_parametros REFERENCIA IDENTIFICADOR 
            {
              Object RESULT =null;
		int tipoleft = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)).left;
		int tiporight = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)).right;
		Object tipo = (Object)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-2)).value;
		int idleft = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).left;
		int idright = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).right;
		Token id = (Token)((java_cup.runtime.Symbol) CUP$parser$stack.peek()).value;
		
								
								Declar_parametros parametros = new Declar_parametros();
								parametros.addTipo((TypeIF)tipo);
								parametros.addId(id.getLexema());
								RESULT = parametros;
								
              CUP$parser$result = parser.getSymbolFactory().newSymbol("lista_declar_parametros",18, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 40: // declar_parametros ::= PARIZQ lista_declar_parametros NT$9 PARDER 
            {
              Object RESULT =null;
              // propagate RESULT from NT$9
                RESULT = (Object) ((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-1)).value;
		int parametrosleft = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)).left;
		int parametrosright = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)).right;
		Object parametros = (Object)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-2)).value;

              CUP$parser$result = parser.getSymbolFactory().newSymbol("declar_parametros",17, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-3)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 39: // NT$9 ::= 
            {
              Object RESULT =null;
		int parametrosleft = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).left;
		int parametrosright = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).right;
		Object parametros = (Object)((java_cup.runtime.Symbol) CUP$parser$stack.peek()).value;

						  RESULT = parametros;
						  
              CUP$parser$result = parser.getSymbolFactory().newSymbol("NT$9",49, ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 38: // declar_parametros ::= PARIZQ PARDER 
            {
              Object RESULT =null;

              CUP$parser$result = parser.getSymbolFactory().newSymbol("declar_parametros",17, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 37: // declar_main ::= VOID MAIN PARIZQ PARDER bloque_sentencias 
            {
              Object RESULT =null;

              CUP$parser$result = parser.getSymbolFactory().newSymbol("declar_main",5, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-4)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 36: // declar_funcion ::= VOID IDENTIFICADOR NT$8 declar_parametros bloque_sentencias 
            {
              Object RESULT =null;
              // propagate RESULT from NT$8
                RESULT = (Object) ((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-2)).value;
		int idleft = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-3)).left;
		int idright = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-3)).right;
		Token id = (Token)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-3)).value;
		int parametrosleft = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)).left;
		int parametrosright = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)).right;
		Object parametros = (Object)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-1)).value;
		int decleft = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).left;
		int decright = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).right;
		Object dec = (Object)((java_cup.runtime.Symbol) CUP$parser$stack.peek()).value;
		
						
						Declaracion declar = new Declaracion();
					Declar_parametros param = new Declar_parametros();
						
					if (dec instanceof Declaracion){
						declar = (Declaracion)dec;
					}
					/*			else
					if(dec instanceof Bloque_sentencias)
							declar.setSentencias((Bloque_sentencias)dec);
						else
							if (dec instanceof Lista_variables_Enteras)
								declar.addListaEnteras((Lista_variables_Enteras)dec);
							else
								declar.addListaMatrices((Lista_variables_matriz)dec);
			*/		ScopeIF sc = scopeManager.getCurrentScope();
	
					System.out.println(declar.introducirTabla(sc));
					
					//Introducimos los parametros en la tabla de simbolos de la funcion
					if (parametros!= null) {
						param = (Declar_parametros)parametros;
						param.introducirParametros(sc,semanticErrorManager,id.getLexema());
					}

					scopeManager.closeScope();
					Bloque_sentencias bloque = ((Declaracion)dec).getSentencias();
					
					if (bloque.tieneReturn("procedimiento")) {

						sc = scopeManager.getCurrentScope();
						SymbolTableIF ts = sc.getSymbolTable();
					
						Declar_funcion funcion = new Declar_funcion();
						funcion.setId(id.getLexema());
						funcion.setParametros((Declar_parametros)parametros);
						funcion.setDeclaracion((Declaracion)dec);
					
						TypeTableIF tt = sc.getTypeTable();
						TypeFunction tipoFuncion = new TypeFunction(sc,id.getLexema());
						tipoFuncion.setListaTipos(param.getListaTipos());
						//Asignar tipo de retorno...
						//Añadir la funcion a la lista de tipos
						tt.addType("id.getLexema()", tipoFuncion);
					
						SymbolFunction sFuncion = new SymbolFunction(sc, id.getLexema(),tipoFuncion);
						sFuncion.setFuncion(funcion);
						ts.addSymbol(sFuncion);
						RESULT = funcion;
					}
					else
						semanticErrorManager.semanticFatalError("La funcion " + id.getLexema() + " tiene salidas a la funcion sin return");

						
						
						
						
						
						
              CUP$parser$result = parser.getSymbolFactory().newSymbol("declar_funcion",15, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-4)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 35: // NT$8 ::= 
            {
              Object RESULT =null;
		int idleft = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).left;
		int idright = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).right;
		Token id = (Token)((java_cup.runtime.Symbol) CUP$parser$stack.peek()).value;

					ScopeIF sc = scopeManager.openScope("Procedimiento");
					SymbolTableIF ts = sc.getSymbolTable();
					if (scopeManager.containsSymbol(id.getLexema())) {
						semanticErrorManager.semanticFatalError("El procedimiento " + id.getLexema() + " ya ha sido declarada en la linea " + id.getLine());

					}
					
	
					
              CUP$parser$result = parser.getSymbolFactory().newSymbol("NT$8",48, ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 34: // declar_funcion ::= ENTERO IDENTIFICADOR NT$7 declar_parametros bloque_sentencias 
            {
              Object RESULT =null;
              // propagate RESULT from NT$7
                RESULT = (Object) ((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-2)).value;
		int idleft = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-3)).left;
		int idright = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-3)).right;
		Token id = (Token)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-3)).value;
		int parametrosleft = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)).left;
		int parametrosright = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)).right;
		Object parametros = (Object)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-1)).value;
		int decleft = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).left;
		int decright = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).right;
		Object dec = (Object)((java_cup.runtime.Symbol) CUP$parser$stack.peek()).value;
		
						Declaracion declar = new Declaracion();
						Declar_parametros param = new Declar_parametros();
							
						if (dec instanceof Declaracion){
							declar = (Declaracion)dec;
						}
						/*			else
						if(dec instanceof Bloque_sentencias)
								declar.setSentencias((Bloque_sentencias)dec);
							else
								if (dec instanceof Lista_variables_Enteras)
									declar.addListaEnteras((Lista_variables_Enteras)dec);
								else
									declar.addListaMatrices((Lista_variables_matriz)dec);
				*/		ScopeIF sc = scopeManager.getCurrentScope();
		
						System.out.println(declar.introducirTabla(sc));
						
						//Introducimos los parametros en la tabla de simbolos de la funcion
						if (parametros!= null) {
							param = (Declar_parametros)parametros;
							param.introducirParametros(sc,semanticErrorManager,id.getLexema());
						}
	
						scopeManager.closeScope();
						Bloque_sentencias bloque = ((Declaracion)dec).getSentencias();
						
						if (bloque.tieneReturn("funcion")) {

							sc = scopeManager.getCurrentScope();
							SymbolTableIF ts = sc.getSymbolTable();
						
							Declar_funcion funcion = new Declar_funcion();
							funcion.setId(id.getLexema());
							funcion.setParametros((Declar_parametros)parametros);
							funcion.setDeclaracion((Declaracion)dec);
						
							TypeTableIF tt = sc.getTypeTable();
							TypeFunction tipoFuncion = new TypeFunction(sc,id.getLexema());
							tipoFuncion.setListaTipos(param.getListaTipos());
							//Asignar tipo de retorno...
							//Añadir la funcion a la lista de tipos
							tt.addType("id.getLexema()", tipoFuncion);
						
							SymbolFunction sFuncion = new SymbolFunction(sc, id.getLexema(),tipoFuncion);
							sFuncion.setFuncion(funcion);
							ts.addSymbol(sFuncion);
							RESULT = funcion;
						}
						else
							semanticErrorManager.semanticFatalError("La funcion " + id.getLexema() + " tiene salidas a la funcion sin return");

					
						
							
						
					
              CUP$parser$result = parser.getSymbolFactory().newSymbol("declar_funcion",15, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-4)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 33: // NT$7 ::= 
            {
              Object RESULT =null;
		int idleft = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).left;
		int idright = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).right;
		Token id = (Token)((java_cup.runtime.Symbol) CUP$parser$stack.peek()).value;

					
					ScopeIF sc = scopeManager.openScope("Funcion");
					SymbolTableIF ts = sc.getSymbolTable();
					if (scopeManager.containsSymbol(id.getLexema())) {
						semanticErrorManager.semanticFatalError("La funcion " + id.getLexema() + " ya ha sido declarada en la linea " + id.getLine());

					}
					
	
					
              CUP$parser$result = parser.getSymbolFactory().newSymbol("NT$7",47, ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 32: // lista_variables_matriz ::= lista_variables_matriz COMA IDENTIFICADOR 
            {
              Object RESULT =null;
		int matricesleft = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)).left;
		int matricesright = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)).right;
		Object matrices = (Object)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-2)).value;
		int idleft = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).left;
		int idright = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).right;
		Token id = (Token)((java_cup.runtime.Symbol) CUP$parser$stack.peek()).value;
		
	
	Lista_variables_matriz listaMat = (Lista_variables_matriz) matrices;
	ScopeIF sc = scopeManager.getCurrentScope();
	SymbolTableIF ts = sc.getSymbolTable();
	TypeTableIF tt = sc.getTypeTable();

	
	if (ts.containsSymbol(id.getLexema())){
		semanticErrorManager.semanticFatalError("Error. La matriz " + id.getLexema() + " ya ha sido declarada en la linea " + id.getLine());
	}

	else {
		TypeArray tipo = (TypeArray)listaMat.getType();
	
			
		if (tt.containsType(tipo.getName())) {

			listaMat.addMatriz(id.getLexema());
			SymbolMatrix mat = new SymbolMatrix(sc,id.getLexema(),tipo,tipo.getR1(),tipo.getR2());
			ts.addSymbol(mat);
			System.out.println(ts);
			RESULT = listaMat;
			}
		
		}



              CUP$parser$result = parser.getSymbolFactory().newSymbol("lista_variables_matriz",14, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 31: // lista_variables_matriz ::= IDENTIFICADOR IDENTIFICADOR 
            {
              Object RESULT =null;
		int id1left = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)).left;
		int id1right = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)).right;
		Token id1 = (Token)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-1)).value;
		int id2left = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).left;
		int id2right = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).right;
		Token id2 = (Token)((java_cup.runtime.Symbol) CUP$parser$stack.peek()).value;
		
	
	ScopeIF sc = scopeManager.getCurrentScope();
	SymbolTableIF ts = sc.getSymbolTable();
	TypeTableIF tt = sc.getTypeTable();

	
	if (ts.containsSymbol(id2.getLexema())){
		semanticErrorManager.semanticFatalError("Error. La matriz " + id2.getLexema() + " ya ha sido declarada en la linea " + id2.getLine());
	}
	else {
		
			if (tt.containsType(id1.getLexema())) {
				TypeArray tipo = (TypeArray)tt.getType(id1.getLexema());
				Lista_variables_matriz listaMat = new Lista_variables_matriz(tipo.getR1(), tipo.getR2(), tipo);
				listaMat.addMatriz(id2.getLexema());
				SymbolMatrix mat = new SymbolMatrix(sc,id2.getLexema(),tipo,tipo.getR1(),tipo.getR2());
				ts.addSymbol(mat);
				RESULT = listaMat;
				
			}
		
		}



              CUP$parser$result = parser.getSymbolFactory().newSymbol("lista_variables_matriz",14, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 30: // lista_variables_enteras ::= lista_variables_enteras COMA IDENTIFICADOR ASIGNACION IDENTIFICADOR 
            {
              Object RESULT =null;
		int varleft = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-4)).left;
		int varright = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-4)).right;
		Object var = (Object)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-4)).value;
		int id1left = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)).left;
		int id1right = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)).right;
		Token id1 = (Token)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-2)).value;
		int id2left = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).left;
		int id2right = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).right;
		Token id2 = (Token)((java_cup.runtime.Symbol) CUP$parser$stack.peek()).value;
		
							
							
							Lista_variables_Enteras listaVar = (Lista_variables_Enteras)var;
							ScopeIF sc = scopeManager.getCurrentScope();
							SymbolTableIF ts = sc.getSymbolTable();
							


							if (ts.containsSymbol(id1.getLexema())){
								semanticErrorManager.semanticFatalError("Error. La variable:" + id1.getLexema() + " ya ha sido declarada en la linea " + id1.getLine());
							}
							else {
								//Comprobamos que exista el símbolo correspondiente
								if (ts.containsSymbol(id2.getLexema())) {
									SymbolIF simbolo = (ts.getSymbol(id2.getLexema()));
									SymbolVariable sVariable;
									listaVar.addVariable(id1.getLexema(),scopeManager.searchType("Entero"));
									//Comprobamos que el símbolo es del tipo adecuado
									if(simbolo.getType() instanceof TypeSimple){	
										//Hacemos casting según sea el tipo variable o constante. A continuación creamos el nuevo símbolo y lo introducimos a la tabla
										if (simbolo instanceof SymbolVariable) {
											
											 
											 sVariable = new SymbolVariable(sc,id1.getLexema(), scopeManager.searchType("Entero"),((SymbolVariable)simbolo).getValor() );

										}
											else {
												sVariable = new SymbolVariable(sc,id1.getLexema(), scopeManager.searchType("Entero"),((SymbolConstant)simbolo).getValor() );

											}
										
										listaVar.setValor(sVariable.getValor());
									
										ts.addSymbol(sVariable);
										ts= listaVar.actualizaValores(ts);

									    

										RESULT = listaVar;
										
										}
								
									else
										semanticErrorManager.semanticFatalError("Error. Asignación incorrecta a la variable:" + id1.getLexema() + "en la línea" + id1.getLine() );

									
							}
								else
									semanticErrorManager.semanticFatalError("Error. No existe el identificador:" + id2.getLexema() + "en la línea" + id1.getLine() );

								
							
							}
								
								
								
								
							
              CUP$parser$result = parser.getSymbolFactory().newSymbol("lista_variables_enteras",13, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-4)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 29: // lista_variables_enteras ::= lista_variables_enteras COMA IDENTIFICADOR ASIGNACION NUMERO 
            {
              Object RESULT =null;
		int varleft = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-4)).left;
		int varright = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-4)).right;
		Object var = (Object)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-4)).value;
		int idleft = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)).left;
		int idright = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)).right;
		Token id = (Token)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-2)).value;
		int valorleft = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).left;
		int valorright = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).right;
		Token valor = (Token)((java_cup.runtime.Symbol) CUP$parser$stack.peek()).value;
		
								
								//Añadimos el valor a la variable que sube y introducimos la nueva
									
									Lista_variables_Enteras listaVar = (Lista_variables_Enteras)var;
									listaVar.setValor(Integer.parseInt(valor.getLexema()));
									ScopeIF sc = scopeManager.getCurrentScope();
									SymbolTableIF ts = sc.getSymbolTable();
								    ts= listaVar.actualizaValores(ts);

							

									if (ts.containsSymbol(id.getLexema())){
										semanticErrorManager.semanticFatalError("Error. La variable:" + id.getLexema() + " ya ha sido declarada en la linea " + id.getLine());
									}
									else {
										if(TypeSimple.rangoCorrecto(Integer.parseInt(valor.getLexema()))){										
											listaVar.addVariable(id.getLexema(),scopeManager.searchType("Entero"));
											SymbolVariable sVariable = new SymbolVariable(sc,id.getLexema(), scopeManager.searchType("Entero"), Integer.parseInt(valor.getLexema()));

											ts.addSymbol(sVariable);
											RESULT = listaVar;
											}
										
										else
											semanticErrorManager.semanticFatalError("Error. El numero " + valor.getLexema() + " excede el rango permitido para las variables en la linea " + valor.getLine());

											
									};
								
								
								
              CUP$parser$result = parser.getSymbolFactory().newSymbol("lista_variables_enteras",13, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-4)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 28: // lista_variables_enteras ::= lista_variables_enteras COMA IDENTIFICADOR 
            {
              Object RESULT =null;
		int varleft = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)).left;
		int varright = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)).right;
		Object var = (Object)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-2)).value;
		int idleft = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).left;
		int idright = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).right;
		Token id = (Token)((java_cup.runtime.Symbol) CUP$parser$stack.peek()).value;
		
								 //Análogo a la versión anterior
									ScopeIF sc = scopeManager.getCurrentScope();
									SymbolTableIF ts = sc.getSymbolTable();


									if (ts.containsSymbol(id.getLexema())){
										semanticErrorManager.semanticFatalError("Error. La variable:" + id.getLexema() + " ya ha sido declarada en la linea " + id.getLine());
									}
									else {
										Lista_variables_Enteras listaVar = (Lista_variables_Enteras)var;
										listaVar.addVariable(id.getLexema(),scopeManager.searchType("Entero"));
										SymbolVariable sVariable = new SymbolVariable(sc,id.getLexema(), scopeManager.searchType("Entero"));

										ts.addSymbol(sVariable);
										RESULT = listaVar;
									}
		
              CUP$parser$result = parser.getSymbolFactory().newSymbol("lista_variables_enteras",13, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 27: // lista_variables_enteras ::= ENTERO IDENTIFICADOR ASIGNACION IDENTIFICADOR 
            {
              Object RESULT =null;
		int id1left = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)).left;
		int id1right = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)).right;
		Token id1 = (Token)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-2)).value;
		int id2left = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).left;
		int id2right = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).right;
		Token id2 = (Token)((java_cup.runtime.Symbol) CUP$parser$stack.peek()).value;
		
									ScopeIF sc = scopeManager.getCurrentScope();
									SymbolTableIF ts = sc.getSymbolTable();

									if (ts.containsSymbol(id1.getLexema())){
										semanticErrorManager.semanticFatalError("Error. La variable:" + id1.getLexema() + " ya ha sido declarada en la linea " + id1.getLine());
									}
									else {
										//Comprobamos que exista el símbolo correspondiente
										if (ts.containsSymbol(id2.getLexema())) {
											SymbolIF simbolo = (ts.getSymbol(id2.getLexema()));
											SymbolVariable sVariable;
											Lista_variables_Enteras listaVar = new Lista_variables_Enteras();											//Comprobamos que el símbolo es del tipo adecuado
											if(simbolo.getType() instanceof TypeSimple){	
												//Hacemos casting según sea el tipo variable o constante. A continuación creamos el nuevo símbolo y lo introducimos a la tabla
												
												listaVar.addVariable(id1.getLexema(),scopeManager.searchType("Entero"));
												if (simbolo instanceof SymbolVariable) {
													 sVariable = new SymbolVariable(sc,id1.getLexema(), scopeManager.searchType("Entero"),((SymbolVariable)simbolo).getValor());

												}
													else {
													 sVariable = new SymbolVariable(sc,id1.getLexema(), scopeManager.searchType("Entero"),((SymbolConstant)simbolo).getValor() );

													}
												
												listaVar.setValor(sVariable.getValor());
												ts.addSymbol(sVariable);
												RESULT = listaVar;
												
												}
										
											else
												semanticErrorManager.semanticFatalError("Error. Asignación incorrecta a la variable:" + id1.getLexema() + "en la línea" + id1.getLine() );

											
									}
										else
											semanticErrorManager.semanticFatalError("Error. No existe el identificador:" + id2.getLexema() + "en la línea" + id1.getLine() );

										
									
									}
		
              CUP$parser$result = parser.getSymbolFactory().newSymbol("lista_variables_enteras",13, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-3)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 26: // lista_variables_enteras ::= ENTERO IDENTIFICADOR ASIGNACION NUMERO 
            {
              Object RESULT =null;
		int idleft = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)).left;
		int idright = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)).right;
		Token id = (Token)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-2)).value;
		int valorleft = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).left;
		int valorright = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).right;
		Token valor = (Token)((java_cup.runtime.Symbol) CUP$parser$stack.peek()).value;
		
									ScopeIF sc = scopeManager.getCurrentScope();
									SymbolTableIF ts = sc.getSymbolTable();

									if (ts.containsSymbol(id.getLexema())){
										semanticErrorManager.semanticFatalError("Error. La variable:" + id.getLexema() + " ya ha sido declarada en la linea " + id.getLine());
									}
									else {
										if(TypeSimple.rangoCorrecto(Integer.parseInt(valor.getLexema()))){										
											Lista_variables_Enteras listaVar = new Lista_variables_Enteras();
											listaVar.addVariable(id.getLexema(),scopeManager.searchType("Entero"));
											listaVar.setValor(Integer.parseInt(valor.getLexema()));
											SymbolVariable sVariable = new SymbolVariable(sc,id.getLexema(),  scopeManager.searchType("Entero"), Integer.parseInt(valor.getLexema()));
											ts.addSymbol(sVariable);
										
											RESULT = listaVar;}
										
										else
											semanticErrorManager.semanticFatalError("Error. El numero " + valor.getLexema() + " excede el rango permitido para las variables en la linea " + valor.getLine());

											
									}
		
              CUP$parser$result = parser.getSymbolFactory().newSymbol("lista_variables_enteras",13, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-3)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 25: // lista_variables_enteras ::= ENTERO IDENTIFICADOR 
            {
              Object RESULT =null;
		int idleft = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).left;
		int idright = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).right;
		Token id = (Token)((java_cup.runtime.Symbol) CUP$parser$stack.peek()).value;
		
									ScopeIF sc = scopeManager.getCurrentScope();
									SymbolTableIF ts = sc.getSymbolTable();

									if (ts.containsSymbol(id.getLexema())){
										semanticErrorManager.semanticFatalError("Error. La variable:" + id.getLexema() + " ya ha sido declarada en la linea " + id.getLine());
									}
									else {
										Lista_variables_Enteras listaVar = new Lista_variables_Enteras();
										listaVar.addVariable(id.getLexema(),scopeManager.searchType("Entero"));
										SymbolVariable sVariable = new SymbolVariable(sc,id.getLexema(), scopeManager.searchType("Entero"));
										ts.addSymbol(sVariable);
										RESULT = listaVar;
									}
		
              CUP$parser$result = parser.getSymbolFactory().newSymbol("lista_variables_enteras",13, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 24: // declar_variable ::= lista_variables_matriz PUNTOYCOMA 
            {
              Object RESULT =null;
		int listaleft = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)).left;
		int listaright = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)).right;
		Object lista = (Object)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-1)).value;
		
						RESULT = lista;
              CUP$parser$result = parser.getSymbolFactory().newSymbol("declar_variable",10, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 23: // declar_variable ::= lista_variables_enteras PUNTOYCOMA 
            {
              Object RESULT =null;
		int listaleft = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)).left;
		int listaright = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)).right;
		Object lista = (Object)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-1)).value;
		
	
	RESULT = lista;


	
              CUP$parser$result = parser.getSymbolFactory().newSymbol("declar_variable",10, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 22: // rango_matriz ::= CORIZQ expresion CORDER 
            {
              Object RESULT =null;
		int exleft = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)).left;
		int exright = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)).right;
		Object ex = (Object)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-1)).value;
		int cleft = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).left;
		int cright = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).right;
		Token c = (Token)((java_cup.runtime.Symbol) CUP$parser$stack.peek()).value;
		
	
		RESULT =  ((Expresion)ex).getValor();

	
              CUP$parser$result = parser.getSymbolFactory().newSymbol("rango_matriz",12, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 21: // rango_matriz_declar ::= CORIZQ IDENTIFICADOR NT$6 CORDER 
            {
              Object RESULT =null;
              // propagate RESULT from NT$6
                RESULT = (Object) ((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-1)).value;
		int rleft = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)).left;
		int rright = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)).right;
		Token r = (Token)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-2)).value;

              CUP$parser$result = parser.getSymbolFactory().newSymbol("rango_matriz_declar",11, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-3)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 20: // NT$6 ::= 
            {
              Object RESULT =null;
		int rleft = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).left;
		int rright = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).right;
		Token r = (Token)((java_cup.runtime.Symbol) CUP$parser$stack.peek()).value;

						
					ScopeIF sc = scopeManager.getCurrentScope();
					SymbolTableIF ts = sc.getSymbolTable();
					
					//Comprobamos que en la tabla de símbolos aparece el simbolo correspondiente. En caso afirmativo recuperamos su valor y comprobamos que no excede el rango.
					if (ts.containsSymbol(r.getLexema())) {
						SymbolIF c = ts.getSymbol(r.getLexema());
						if (TypeSimple.rangoPositivo(((SymbolConstant)c).getValor())) {
							RESULT = ((SymbolConstant)c).getValor();
						}
						else
							semanticErrorManager.semanticFatalError("Error. El numero " + r.getLexema() + " excede el rango permitido en  la matriz en la linea " + r.getLine());
					}
					else 	semanticErrorManager.semanticFatalError("Error. No existe el identificador " + r.getLexema() + "  en la linea " + r.getLine());
						
					
              CUP$parser$result = parser.getSymbolFactory().newSymbol("NT$6",46, ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 19: // rango_matriz_declar ::= CORIZQ NUMERO NT$5 CORDER 
            {
              Object RESULT =null;
              // propagate RESULT from NT$5
                RESULT = (Object) ((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-1)).value;
		int rleft = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)).left;
		int rright = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)).right;
		Token r = (Token)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-2)).value;

              CUP$parser$result = parser.getSymbolFactory().newSymbol("rango_matriz_declar",11, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-3)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 18: // NT$5 ::= 
            {
              Object RESULT =null;
		int rleft = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).left;
		int rright = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).right;
		Token r = (Token)((java_cup.runtime.Symbol) CUP$parser$stack.peek()).value;

						if (TypeSimple.rangoPositivo(Integer.parseInt(r.getLexema()))){
							RESULT =Integer.parseInt(r.getLexema());
						}
						else
							semanticErrorManager.semanticFatalError("Error. El numero " + r.getLexema() + " excede el rango permitido en  la matriz en la linea " + r.getLine());
							
						
					
              CUP$parser$result = parser.getSymbolFactory().newSymbol("NT$5",45, ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 17: // declar_tipo ::= ENTERO IDENTIFICADOR rango_matriz_declar rango_matriz_declar NT$4 PUNTOYCOMA 
            {
              Object RESULT =null;
              // propagate RESULT from NT$4
                RESULT = (Object) ((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-1)).value;
		int idleft = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-4)).left;
		int idright = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-4)).right;
		Token id = (Token)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-4)).value;
		int r1left = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-3)).left;
		int r1right = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-3)).right;
		Object r1 = (Object)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-3)).value;
		int r2left = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)).left;
		int r2right = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)).right;
		Object r2 = (Object)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-2)).value;

              CUP$parser$result = parser.getSymbolFactory().newSymbol("declar_tipo",8, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-5)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 16: // NT$4 ::= 
            {
              Object RESULT =null;
		int idleft = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)).left;
		int idright = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)).right;
		Token id = (Token)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-2)).value;
		int r1left = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)).left;
		int r1right = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)).right;
		Object r1 = (Object)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-1)).value;
		int r2left = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).left;
		int r2right = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).right;
		Object r2 = (Object)((java_cup.runtime.Symbol) CUP$parser$stack.peek()).value;

					ScopeIF sc = scopeManager.getCurrentScope();
					TypeTableIF tt = sc.getTypeTable();
					if (tt.containsType(id.getLexema()))
						semanticErrorManager.semanticFatalError("Error. El tipo:" + id.getLexema() + " ya ha sido declarado con anterioridad en la linea " + id.getLine());
					else {
						TypeArray matriz = new TypeArray(sc,id.getLexema(), (int)r1,(int)r2);
						tt.addType(id.getLexema(),matriz);
						Declar_tipo tipo = new Declar_tipo(id.getLexema(), (int)r1, (int)r2);
						RESULT =  tipo;
						
					

					}
	
	
	
              CUP$parser$result = parser.getSymbolFactory().newSymbol("NT$4",44, ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 15: // declar_const ::= DEFINE IDENTIFICADOR NUMERO NT$3 PUNTOYCOMA 
            {
              Object RESULT =null;
              // propagate RESULT from NT$3
                RESULT = (Object) ((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-1)).value;
		int idleft = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-3)).left;
		int idright = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-3)).right;
		Token id = (Token)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-3)).value;
		int valorleft = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)).left;
		int valorright = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)).right;
		Token valor = (Token)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-2)).value;

              CUP$parser$result = parser.getSymbolFactory().newSymbol("declar_const",6, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-4)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 14: // NT$3 ::= 
            {
              Object RESULT =null;
		int idleft = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)).left;
		int idright = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)).right;
		Token id = (Token)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-1)).value;
		int valorleft = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).left;
		int valorright = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).right;
		Token valor = (Token)((java_cup.runtime.Symbol) CUP$parser$stack.peek()).value;

				ScopeIF sc = scopeManager.getCurrentScope();
				SymbolTableIF ts = sc.getSymbolTable();
				
				if (ts.containsSymbol(id.getLexema())){
					semanticErrorManager.semanticFatalError("La constante:" + id.getLexema() + " ya ha sido declarada en la linea " + id.getLine());
				}
				else {
					if (TypeSimple.rangoCorrecto(Integer.parseInt(valor.getLexema()))) {
						SymbolConstant sConstant = new SymbolConstant(sc,id.getLexema(), scopeManager.searchType("Entero"), Integer.parseInt(valor.getLexema()));
						Declar_const c = new Declar_const(Integer.parseInt(valor.getLexema()),"Constante");
						ts.addSymbol(sConstant);
						RESULT = c;
					}
					else
						semanticErrorManager.semanticFatalError("Error. La constante:" + id.getLexema() + " tiene un valor fuera de rango en la linea" + id.getLine());
					
					
				}
				
              CUP$parser$result = parser.getSymbolFactory().newSymbol("NT$3",43, ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 13: // declar_funciones_glo ::= declar_main 
            {
              Object RESULT =null;

              CUP$parser$result = parser.getSymbolFactory().newSymbol("declar_funciones_glo",4, ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 12: // declar_funciones_glo ::= declar_funcion declar_funciones_glo 
            {
              Object RESULT =null;

              CUP$parser$result = parser.getSymbolFactory().newSymbol("declar_funciones_glo",4, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 11: // declar_variables_glo ::= declar_funciones_glo 
            {
              Object RESULT =null;

              CUP$parser$result = parser.getSymbolFactory().newSymbol("declar_variables_glo",3, ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 10: // declar_variables_glo ::= declar_variable declar_variables_glo 
            {
              Object RESULT =null;

              CUP$parser$result = parser.getSymbolFactory().newSymbol("declar_variables_glo",3, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 9: // declar_tipos_glo ::= declar_variables_glo 
            {
              Object RESULT =null;

              CUP$parser$result = parser.getSymbolFactory().newSymbol("declar_tipos_glo",2, ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 8: // declar_tipos_glo ::= declar_tipo declar_tipos_glo 
            {
              Object RESULT =null;

              CUP$parser$result = parser.getSymbolFactory().newSymbol("declar_tipos_glo",2, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 7: // declar_consts ::= declar_tipos_glo 
            {
              Object RESULT =null;

              CUP$parser$result = parser.getSymbolFactory().newSymbol("declar_consts",1, ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 6: // declar_consts ::= declar_const NT$2 declar_consts 
            {
              Object RESULT =null;
              // propagate RESULT from NT$2
                RESULT = (Object) ((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-1)).value;
		int cleft = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)).left;
		int cright = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)).right;
		Object c = (Object)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-2)).value;

              CUP$parser$result = parser.getSymbolFactory().newSymbol("declar_consts",1, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 5: // NT$2 ::= 
            {
              Object RESULT =null;
		int cleft = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).left;
		int cright = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).right;
		Object c = (Object)((java_cup.runtime.Symbol) CUP$parser$stack.peek()).value;

	
			RESULT = c;
			
              CUP$parser$result = parser.getSymbolFactory().newSymbol("NT$2",42, ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 4: // axiom ::= NT$1 declar_consts 
            {
              Axiom RESULT =null;
              // propagate RESULT from NT$1
                RESULT = (Axiom) ((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-1)).value;

              CUP$parser$result = parser.getSymbolFactory().newSymbol("axiom",35, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 3: // NT$1 ::= 
            {
              Axiom RESULT =null;

	
			//Abrimos el ámbito global, creamos los tipos y los añadimos a la tabla de símbolos
			ScopeIF ambito = scopeManager.openScope("Global");
			
			System.out.println("Tras abrir ambito principal "+ ambito);
			TypeTableIF tt = ambito.getTypeTable();
			TypeSimple entero = new TypeSimple(ambito,"Entero");
			tt.addType("Entero",entero);
			
			TypeVoid vacio = new TypeVoid(ambito,"Vacio");
			tt.addType("Vacio", vacio);
			
			
		
			
			
              CUP$parser$result = parser.getSymbolFactory().newSymbol("NT$1",41, ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 2: // program ::= NT$0 axiom 
            {
              Object RESULT =null;
              // propagate RESULT from NT$0
                RESULT = (Object) ((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-1)).value;
		int axleft = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).left;
		int axright = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).right;
		Axiom ax = (Axiom)((java_cup.runtime.Symbol) CUP$parser$stack.peek()).value;
		 
  		// No modificar esta estructura, aunque se pueden añadir más acciones semánticas
  		
  		//List intermediateCode = ax.getIntermediateCode ();
  		//finalCodeFactory.create (intermediateCode);
  		// En caso de no comentarse las sentencias anteriores puede generar una excepcion
  		// en las llamadas a cupTest si el compilador no está completo. Esto es debido a que 
  		// aún no se tendrá implementada la generación de código intermedio ni final.
  		// Para la entrega final deberán descomentarse y usarse.
  		
  		syntaxErrorManager.syntaxInfo ("Parsing process ended.");
  
              CUP$parser$result = parser.getSymbolFactory().newSymbol("program",0, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 1: // NT$0 ::= 
            {
              Object RESULT =null;
 syntaxErrorManager.syntaxInfo ("Starting parsing..."); 
	
	
  
              CUP$parser$result = parser.getSymbolFactory().newSymbol("NT$0",40, ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 0: // $START ::= program EOF 
            {
              Object RESULT =null;
		int start_valleft = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)).left;
		int start_valright = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)).right;
		Object start_val = (Object)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-1)).value;
		RESULT = start_val;
              CUP$parser$result = parser.getSymbolFactory().newSymbol("$START",0, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          /* ACCEPT */
          CUP$parser$parser.done_parsing();
          return CUP$parser$result;

          /* . . . . . .*/
          default:
            throw new Exception(
               "Invalid action number found in internal parse table");

        }
    }
}

